var fs = require("fs");
var oop = require("oop").oop;
var now = require("performance-now");



/**
 * @param {Object} parser Instance of a parser
 * @param {Object} params It contains:
 * - rule {String}: the rule to use
 * - output {Object|Array|String|Boolean}: the expected output. If false, it means that a failure is expected
 * @return {Object} It contains:
 * - output {Object|Array|String}: the actual output,
 * - result {Boolean}: whether the expectedOutput corresponds to the actual output,
 * - duration {Number}: the duration of the parse operation in milliseconds
 * - failure {Boolean}: true if the parser has failed
 */
var testSingleParseOperation = function(parser, params) {
	var expectedFailure = (params.output === false);
	var start = now(), failure = false;
	try {
		var parsedTree = parser.parse(params.input, {
			startRule: params.rule || "start"
		});
	} catch(ex) {
		failure = true;
	}

	var end = now();

	var actualOutput = failure ? null : convertToObject(parsedTree);

	return {
		output: actualOutput,
		result: expectedFailure ? failure : objectIncludes(params.output, actualOutput),
		duration: end - start,
		failure: failure
	};
};


/**
 * If the two inputs are strings, it returns true if the strings are equal.
 *
 * If the two inputs are objects, it returns true if
 * - "small" and "big" are equal strings
 * - all properties contained in "small" (apart from "children") are also contained in "big", and they are equal
 * - "small" and "big" have the same number of children
 * - each child of "small" is included in the corresponding child of "big"
 *
 * If the two inputs are arrays, it returns true if each of the entry of "small" is included in the corresponding entry of "big".
 *
 * @param {Object} small
 * @param {Object} big
 * @return {Boolean}
 */
var objectIncludes = function(small, big) {
	if (isString(small) && isString(big)) {
		return small == big;
	}
	if (isArray(small) && isArray(big)) {
		if (small.length == big.length) {
			for (var i = 0, length = small.length; i < length; i++) {
				if (!objectIncludes(small[i], big[i])) {
					return false;
				}
			}
		} else {
			return false;
		}
	} else if (isObject(small) && isObject(big)) {

		for (var key in small) {
			if (small.hasOwnProperty(key) && key != "children") {
				if (!equals(small[key], big[key])) {
					return false;
				}
			}
		}
		return objectIncludes(small.children, big.children);
	} else {
		return false;
	}

	return true;
};


/**
 * Returns true if the two arguments are equal. Equality for array and objects is recursively assessed
 *
 * @param {Object} one
 * @param {Object} two
 * @return {Boolean}
 */
var equals = function(one, two) {
	var toString = Object.prototype.toString;
	var typeOne = toString.apply(one);
	var typeTwo = toString.apply(two);
	if (typeOne != typeTwo) {
		return false;
	}
	if (typeOne == "[object Array]") {
		if (one.length != two.length) {
			return false;
		}
		for (var i = 0, len = one.length; i < len; i++) {
			if (! equals(one[i], two[i])) {
				return false;
			}
		}
		return true;
	}
	if (typeOne == "[object Object]") {
		if (!equals(Object.keys(one), Object.keys(two))) {
			return false;
		}
		for (var key in one) {
			if (one.hasOwnProperty(key)) {
				if (!equals(one[key], two[key])) {
					return false;
				}
			}
		}
		return true;
	}
	return one == two;
};

/**
 * Returns true if arg is an Array
 *
 * @param {Object} arg
 * @return {Boolean}
 */
var isArray = function(arg) {
	return (Object.prototype.toString.apply(arg) == "[object Array]");
};

/**
 * Returns true if arg is an Object
 *
 * @param {Object} arg
 * @return {Boolean}
 */
var isObject = function(arg) {
	return (Object.prototype.toString.apply(arg) == "[object Object]");
};

/**
 * Returns true if arg is a String
 *
 * @param {Object} arg
 * @return {Boolean}
 */
var isString = function(arg) {
	return (Object.prototype.toString.apply(arg) == "[object String]");
};

/**
 * Converts the parsed tree into a simpler object. If the input is a string, it just returns it.
 *
 * @param {Object|Array|String} arg
 * @return {Object|Array|String}
 */
var convertToObject = function(input) {
	var output;
	if (isString(input)) {
		return input;
	}
	if (isArray(input)) {
		output = [];
		for (var i = 0, len = input.length; i < len; i++) {
			output.push(input[i].toObject());
		}
	} else {
		output = input.toObject();
	}
	return output;
};


/**
 * Class that only exposes a testParser method in order to test the output of a parser
 */
var ParserTester = oop.Class({
	name: 'ParserTester',
	desc: 'A ParserTester is needed in order to ascertain that the graph issued from the parser is the same as the expected graph that is stored in a file.',

	/**
	 * @param {Object} args. It contains
	 * - parser {Object} (mandatory): the parser to test
	 * - basepath {String}: the basepath of the test resources. It defaults to the empty string
	 * - extension {String}: the extension of the files containing input strings for the parser. It defaults to ".txt"
	 */
	constructor: function(args) {
		this.parser = args.parser;
		this.basepath = args.basepath || "";
		this.extension = args.extension || "txt";
		this.beforeEachTest = args.beforeEachTest || function() {};
	},

	statics : {
		INPUT_SUFFIX: "-input",
		OUTPUT_SUFFIX: "-output.json"
	},

	methods: {

		/**
		 * Tests whether the graph generated from parsing a certain string has the same structure as the one stored in a file
		 *
		 * @param {Object} params It contains
		 * - name {String}: the name of the test. It is used in order to retrieve the input test files.
		 *     In particular, the file in which the input string is retrieved is <name><INPUT_SUFFIX>.<extension>. The file in which the expected JSON is stored has to be <name><OUTPUT_SUFFIX>
		 * - rule {String}: the rule that the parser will be instructed to use in order to parse the given string. It defaults to "start"
		 * - multiple {Boolean}: true is the input file has to considered as a JSON containing an array of input strings
		 * - display {Boolean}: whether to output the expected file in the console,
		 * - failure {Boolean}: whether the parser is expected to fail
		 * - toFile {String}: if present, the value will be used in order to write the result
		 *
		 * @return {Object} It contains:
		 * - result {Boolean}: whether the output of the parser corresponds to the expected output stored in the file corresponding to the name. The comparison is flexible (see objectIncludes method documentation).
		 *   if the parser is expected to fail, the result will be true if it has failed
		 * - duration {Number}: duration of the parse operation in milliseconds
		 * - failure {Boolean}: true if the parser has failed
		 */
		testParser: function(params) {
			var name = params.name, output;
			var input = fs.readFileSync(this.basepath + name + ParserTester.INPUT_SUFFIX + "." + this.extension, "utf-8");
			var expectedOutput;
			if (!params.failure) {
				var outputContent = fs.readFileSync(this.basepath + name + ParserTester.OUTPUT_SUFFIX, "utf-8");
				try {
					expectedOutput = JSON.parse(outputContent);
				} catch(ex) {
					expectedOutput = outputContent;
				}
			} else {
				expectedOutput = false;
			}

			if (params.multiple) {
				input = JSON.parse(input);
				output = {
					output: [],
					result: true,
					duration : 0,
					failure: false
				};
				for (var i = 0, len = input.length; i < len; i++) {
					this.beforeEachTest();
					var singleOutput = testSingleParseOperation(this.parser, {
						input: input[i],
						output: !expectedOutput ? false : expectedOutput[i],
						rule: params.rule
					});
					output.output.push(singleOutput.output);
					output.result = output.result && singleOutput.result;
					output.duration += singleOutput.duration;
					output.failure = output.failure || singleOutput.failure;
				}

			} else {
				this.beforeEachTest();
				output =  testSingleParseOperation(this.parser, {
					input: input,
					output: expectedOutput,
					rule: params.rule
				});
			}

			if (params.display) {
				console.log("\nRule " + params.rule + " ________________________________");
				console.log("\n" + JSON.stringify(output.output, null, "    "));
				console.log("\nduration: " + output.duration + " ms");
			}

			if (params.toFile) {
				fs.writeFileSync(this.basepath + params.toFile, JSON.stringify(output.output, null, "    "), "utf-8");
			}

			return {
				result: output.result,
				duration: output.duration,
				failure: output.failure
			};

		}
	}
});


module.exports.ParserTester = ParserTester;