var fs = require("fs");
var oop = require('oop').oop;


/**
 * @param {Object} parser Instance of a parser
 * @param {Object} params It contains:
 * - rule {String}: the rule to use
 * - output {Object}: the expected output
 * @return {}
 */
var testSingleParseOperation = function(parser, params) {
	var actualOutput = convertToObject(parser.parse(params.input, {
		startRule: params.rule || "start"
	}));

	return {
		output: actualOutput,
		result: objectIncludes(params.output, actualOutput)
	};
};


/**
 * Returns true if
 * - all properties contained in one (apart from children) are also cotained in two, and they are equal
 * - one and two have the same number of children
 * - each child of one is included in the corresponding child of two
 *
 * If the two inputs are arrays, it returns true if each of the entry of one is included in the corresponding entry of two
 *
 * @param {Object} one
 * @param {Object} two
 * @return {Boolean}
 */
var objectIncludes = function(one, two) {

	if (isArray(one) && isArray(two)) {
		if (one.length == two.length) {
			for (var i = 0, length = one.length; i < length; i++) {
				if (!objectIncludes(one[i], two[i])) {
					return false;
				}
			}
		} else {
			return false;
		}
	} else if (isObject(one) && isObject(two)) {

		for (var key in one) {
			if (one.hasOwnProperty(key) && key != "children") {
				if (!equals(one[key], two[key])) {
					return false;
				}
			}
		}
		return objectIncludes(one.children, two.children);
	} else {
		return false;
	}

	return true;
};


/**
 * Returns true if the two arguments are equal. Equality for array and objects is recursively assessed
 *
 * @param {Object} one
 * @param {Object} two
 * @return {Boolean}
 */
var equals = function(one, two) {
	var toString = Object.prototype.toString;
	var typeOne = toString.apply(one);
	var typeTwo = toString.apply(two);
	if (typeOne != typeTwo) {
		return false;
	}
	if (typeOne == "[object Array]") {
		if (one.length != two.length) {
			return false;
		}
		for (var i = 0, len = one.length; i < len; i++) {
			if (! equals(one[i], two[i])) {
				return false;
			}
		}
		return true;
	}
	if (typeOne == "[object Object]") {
		if (!equals(Object.keys(one), Object.keys(two))) {
			return false;
		}
		for (var key in one) {
			if (one.hasOwnProperty(key)) {
				if (!equals(one[key], two[key])) {
					return false;
				}
			}
		}
		return true;
	}
	return one == two;
};

/**
 * Returns true if arg is an Array
 *
 * @param {Object} arg
 * @return {Boolean}
 */
var isArray = function(arg) {
	return (Object.prototype.toString.apply(arg) == "[object Array]");
};

/**
 * Returns true if arg is an Object
 *
 * @param {Object} arg
 * @return {Boolean}
 */
var isObject = function(arg) {
	return (Object.prototype.toString.apply(arg) == "[object Object]");
};

/**
 * Converts the parsed tree into a simpler object
 *
 * @param {Object|Array} arg
 * @return {Object|Array}
 */
var convertToObject = function(input) {
	var output;
	if (isArray(input)) {
		output = [];
		for (var i = 0, len = input.length; i < len; i++) {
			output.push(input[i].toObject());
		}
	} else {
		output = input.toObject();
	}
	return output;
};


/**
 * Class that only exposes a testParser method in order to test the output of a parser
 */
var ParserTester = oop.Class({
	name: 'ParserTester',
	desc: 'A ParserTester is needed in order to ascertain that the graph issued from the parser is the same as the expected graph that is stored in a file.',

	/**
	 * @param {Object} args. It contains
	 * - parser {Object} (mandatory): the parser to test
	 * - basepath {String}: the basepath of the test resources. It defaults to the empty string
	 * - extension {String}: the extension of the files containing input strings for the parser. It defaults to ".txt"
	 */
	constructor: function(args) {
		this.parser = args.parser;
		this.basepath = args.basepath || "";
		this.extension = args.extension || "txt";
	},

	statics : {
		INPUT_SUFFIX: "-input",
		OUTPUT_SUFFIX: "-output.json"
	},

	methods: {

		/**
		 * Tests whether the graph generated from parsing a certain string has the same structure as the one stored in a file
		 *
		 * @param {Object} params It contains
		 * - name {String}: the name of the test. It is used in order to retrieve the input test files.
		 *     In particular, the file in which the input string is retrieved is <name><INPUT_SUFFIX>.<extension>. The file in which the expected JSON is stored has to be <name><OUTPUT_SUFFIX>
		 * - rule {String}: the rule that the parser will be instructed to use in order to parse the given string. It defaults to "start"
		 * - multiple {Boolean}: true is the input file has to considered as a JSON containing an array of input strings
		 * - display {Boolean}: whether to output the expected file in the console
		 *
		 * @return {Boolean} Whether the output of the parser corresponds to the expected output stored in the file corresponding to the name. The comparison is flexible (see objectIncludes method documentation).
		 */
		testParser: function(params) {

			var name = params.name, output;
			var input = fs.readFileSync(this.basepath + name + ParserTester.INPUT_SUFFIX + "." + this.extension, "utf-8");
			var expectedOutput = JSON.parse(fs.readFileSync(this.basepath + name + ParserTester.OUTPUT_SUFFIX, "utf-8"));

			if (params.multiple) {
				input = JSON.parse(input);
				output = {
					output: [],
					result: true
				};
				for (var i = 0, len = input.length; i < len; i++) {
					var singleOutput = testSingleParseOperation(this.parser, {
						input: input[i],
						output: expectedOutput[i],
						rule: params.rule
					});
					output.output.push(singleOutput.output);
					output.result = output.result && singleOutput.result;
				}

			} else {
				output =  testSingleParseOperation(this.parser, {
					input: input,
					output: expectedOutput,
					rule: params.rule
				});
			}

			if (params.display) {
				console.log("\n" + JSON.stringify(output.output, null, "    "));
			}

			return output.result;

		}
	}
});


module.exports.ParserTester = ParserTester;