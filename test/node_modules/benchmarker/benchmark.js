var prelude = require('prelude-ls');
var now = require("performance-now");

var oop = require('oop').oop;

// TODO? Run the function at least one time without getting the result, to avoid initialization overhead?

var Benchmark = oop.Class({
	name: 'Benchmark',

	description: 'A benchmark',

	schema: {
		properties: [
			// Benchmark identification / description
			{names: ['name', 'id', 'ID'], required: true},

			{names: ['description', 'desc', 'doc', 'documentation', 'explanation'], required: false},

			// Function to test
			{names: ['fn', 'func', 'cb', 'handler', 'exec', 'process', 'run'], required: true},

			['context', 'scope', 'environment', 'env', 'that', 'self'],

			{
				names: ['args', 'arguments', 'arg', 'argument', 'params', 'parameters', 'param', 'parameter'],
				type: oop.types.Array, default: []
			},

			// Benchmark properties
			{
				names: ['max_time', 'max-time'],
				desc: 'The maximum time to run the benchmark. Doesn\'t take into account the first run if drop_first is enabled. has precedence over the min_reps constraint. However, at least one run must be made for the benchmark, and this one can last any long.',
				type: oop.types.Number, default: 1000
			},
			{
				names: ['min_reps', 'min-reps', 'reps'],
				desc: 'The prefered number of repetitions to execute.',
				type: oop.types.Number, default: 5
			},
			{
				names: ['drop_first', 'drop-first'],
				desc: 'Before running the benchmark, run the function once, to avoid initialization side-effects',
				type: oop.types.Boolean, default: true
			}
		]
	},

	statics: {
		computeStats: function(result) {
			var times = result.times;

			// Executions
			var executions = times.length;

			// Total time, just to know
			var total = prelude.sum(times);
			// Mean time
			var mean_ns = (total / executions) * 1000;
			var mean_ms = total / executions;
			var mean_s = total / executions / 1000;
			// Ops/s
			var ops_ns = 1 / mean_ns;
			var ops_ms = 1 / mean_ms;
			var ops_s = 1 / mean_s;
			// Deviation

			// variance

			// -------

			return {
				executions: executions,
				total: total,

				mean_ns: mean_ns,
				mean_ms: mean_ms,
				mean_s: mean_s,

				ops_ns: ops_ns,
				ops_ms: ops_ms,
				ops_s: ops_s
			}
		},
	},

	init: function() {
		if (this.context == null) {this.context = this}
	},

	proto: {
		run: function() {
			var totalTime = 0;

			if (this.drop_first) {
				this.execOnce();
			}

			var times = [];
			for (
				var executions = 0, min_reps = this.min_reps;
				executions < min_reps;
				executions++
			) {
				var time = this.execOnce();

				times.push(time);

				totalTime += time;
				if (totalTime >= this.max_time) {
					break;
				}
			}

			return {
				times: times
			};
		},

		runSimple: function() {
			var totalTime = 0;

			var times = [];
			for (
				var executions = 0, min_reps = this.min_reps;
				executions < min_reps && totalTime < this.max_time;
				executions++
			) {
				var time = this.execOnceSimple();
				times.push(time);
				totalTime += time;
			}

			return {
				executions: executions,
				times: times,
				totalTime: totalTime
			};
		},

		execOnce: function() {
			var start = now();
			this.fn.apply(this.context, this.args);
			var end = now();
			return end - start;
		},

		execOnceSimple: function() {
			var start = now();
			this.fn();
			var end = now();
			return end - start;
		}

	}
})




exports.Benchmark = Benchmark;
