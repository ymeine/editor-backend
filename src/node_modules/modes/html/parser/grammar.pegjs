// Initializer -----------------------------------------------------------------

{
	var lib = require('editor/pegjs-parser/initializer');

	var Node = new lib.NodeInstancier('html', true);

	var blocks = [
		'cdata',
		'text',
		'block'
	];

	Node.addHook(function(node) {
		if (blocks.indexOf(node.type.element) >= 0) {
			node.flag('block');
		}
	});

	var blockOpeningStack = [];
}



// Grammar ---------------------------------------------------------------------

// ------------------------------------------------------------------------ Root

start = ws0:__ nodes:(nodeList __)? {
	var node = Node('root', null, null, offset(), text());

	node.addList('spaces.0', ws0);

	if (nodes !== null) {
		node.addList('nodes', nodes[0]);
		node.addList('spaces.1', nodes[1]);
	}

	return node;
}

// ----------------------------------------------------------------------- Nodes

node =
	element
	/ text

// FIXME This rule is used to parse a list of nodes contained in a block element (most of the time)
// These nodes are a mix of text, elements, and comments also.
// However, concerning the comments, they are "eaten" by the "__" rule, whose content is skipped here.
// So concretely if a node contains only text except some content inside, these comments are ignored because of that.
// Review the design of this rule
nodeList = head:node rest:(__ node)* {
	return lib.listFromSequence(head, rest);
}

// ------------------------------------------------------------------------ Text
// The particularity of the text node, is that it is not delimited as other nodes - that is elements, it's just everything that is not an element. So to detect the end of a text, we need to check if an element starts.

text = $(!elementStart .)+ {
	return Node('text', null, null, offset(), text());
}

// -------------------------------------------------------------------- Elements
// WARNING the precedence in alternatives is important!

element =
	directiveElement
	/ inline
	/ block
	/ node:closing &{
		// This closing has no ID, it's necessarily orphan ---------------------
		var nodeID = node.childrenIndex.id;
		if (nodeID == null) {
			return true;
		}

		// There wasn't any block (with an ID of course) to close, this closing is an orphan -------
		var lastBlockOpening = blockOpeningStack[blockOpeningStack.length - 1];
		if (lastBlockOpening == null) {
			return true;
		}

		// The closing ID doesn't match the latest opened block, it's orphan ---
		var lastID = lastBlockOpening.childrenIndex.id;
		return (lastID.source !== nodeID.source);
	} {
		node.flag('error');
		node.set('error', "Closing tag doesn't match any opening tag");

		return node;
	}
	/ (!closingOpening node:elementStart) {
		node.flag('error');
		node.set('error', 'Unknow element');
		return node;
	}

elementStart = "<" {
	return Node('opening', null, null, offset(), text());
}

// ---------------------------------------------------------- Directive elements

directiveElement =
	cdata
	/ directive
	/ node:directiveOpening {
		node.flag('error');
		node.set('error', 'Unknow directive element');
		return node;
	}

directiveOpening = "<!" {
	return Node('opening', null, null, offset(), text());
}

// ----------------------------------------------------------------------- CDATA

cdata = opening:cdataOpening content:cdataContent? closing:cdataClosing? {
	var node = Node('cdata', null, null, offset(), text());

	node.add('opening', opening);

	if (content !== null) {
		node.add('content', content);
	}

	if (closing !== null) {
		node.add('closing', closing);
	} else {
		node.flag('error');
		node.set('error', 'CDATA block not closed');
	}

	return node;
}

cdataOpening = "<![CDATA[" {
	return Node('opening', null, null, offset(), text());
}

cdataClosing = "]]>" {
	return Node('closing', null, null, offset(), text());
}

cdataContent = (!cdataClosing .)+ {
	return Node('content', null, null, offset(), text());
}

// ------------------------------------------------------------------- Directive

directive = opening:directiveOpening ws0:__ id:id? ws1:__ content:directiveContent? closing:directiveClosing? {
	var node = Node('directive', null, null, offset(), text());

	var errors = [];

	node.add('opening', opening);

	node.addList('spaces.0', ws0);

	if (id !== null) {
		node.add('id', id);
	} else {
		node.flag('error');
		errors.push('Directive is missing id');
		node.set('error', errors);
	}

	node.addList('spaces.1', ws1);

	if (content !== null) {
		node.add('content', content);
	}

	if (closing !== null) {
		node.add('closing', closing);
	} else {
		node.flag('error');
		errors.push('Directive is not closed');
		node.set('error', errors);
	}

	return node;
}

directiveClosing = ">" {
	return Node('closing', null, null, offset(), text());
}

directiveContent = (!directiveClosing .)+ {
	var node = Node('text', null, null, offset(), text());
	return node;
}

// ---------------------------------------------------------------------- Inline

inline = opening:inlineOpening id:inlineIds ws0:__ attributes:(attributeList __)? closing:inlineClosing? {
	var node = Node('inline', null, null, offset(), text());

	node.add('opening', opening);
	node.add('tag', id);
	node.addList('spaces.0', ws0);

	if (attributes !== null) {
		node.addList('attributes', attributes[0]);
		node.addList('spaces.1', attributes[1]);
	}

	if (closing !== null) {
		node.add('closing', closing);
	} else {
		node.flag('error');
		node.set('error', 'Inline element not closed');
	}

	return node;
}

inlineOpening = "<" {
	return Node('opening', null, null, offset(), text());
}

inlineClosing = slash:(slash __)? closing:closingAngleBracket {
	var node = Node('closing', null, null, offset(), text());

	if (slash !== null) {
		node.add('slash', slash[0]);
		node.addList('spaces.2', slash[1]);
	}

	node.add('closingAngleBracket', closing);

	return node;
}

inlineIds = (
	"br"
	/ "link"
	/ "meta"
	/ "input"
	/ "img"
) {
	var node = Node('id', null, null, offset(), text());
	node.set('value', text());
	return node;
}

// ----------------------------------------------------------------------- Block

block = !closing open:opening ws0:__ nodes:(nodeList __)? close:closing? {
	var node = Node('block', null, null, offset(), text());
	var errors = [];

	node.add('openTag', open);

	node.addList('spaces.0', ws0);

	if (nodes !== null) {
		node.addList('nodes', nodes[0]);
		node.addList('spaces.1', nodes[1]);
	}

	if (close !== null) {
		node.add('closeTag', close);
		blockOpeningStack.pop();
	} else {
		node.flag('error');
		errors.push('Block is not closed');
		node.set('error', errors);
	}

	return node;
}

opening = opening:openingOpening id:id? ws0:__ attributes:(attributeList __)? closing:openingClosing? {
	var node = Node('opening', null, null, offset(), text());
	var errors = [];

	node.add('opening', opening);

	if (id !== null) {
		blockOpeningStack.push(node);
		node.add('id', id);
	} else {
		node.flag('error');
		errors.push('Block opening tag is missing id');
		node.set('error', errors);
	}

	node.addList('spaces.0', ws0);

	if (attributes !== null) {
		node.addList('attributes', attributes[0]);
		node.addList('spaces.1', attributes[1]);
	}

	if (closing !== null) {
		node.add('closing', closing);
	} else {
		node.flag('error');
		errors.push('Opening tag not closed');
		node.set('error', errors);
	}

	return node;
}

openingOpening = "<" {
	return Node('opening', null, null, offset(), text());
}

openingClosing = ">" {
	return Node('closing', null, null, offset(), text());
}

closing = opening:closingOpening ws0:__ id:id? ws1:__ closing:closingClosing? {
	var node = Node('closing', null, null, offset(), text());
	var errors = [];

	node.add('opening', opening);

	node.addList('spaces.0', ws0);

	if (id != "") {
		node.add('id', id);
	} else {
		node.flag('error');
		errors.push('Closing contains no id');
		node.set('errors', errors);
	}

	node.addList('spaces.1', ws1);

	if (closing !== null) {
		node.add('closing', closing);
	} else {
		node.flag('error');
		errors.push('Closing tag not closed');
		node.set('errors', errors);
	}

	return node;
}

closingOpening = "</" {
	return Node('opening', null, null, offset(), text());
}

closingClosing = ">" {
	return Node('closing', null, null, offset(), text());
}


// ------------------------------------------------------------------- Attribute

attribute = key:id value:(__ attributeAssignmentOperator __ attrValue?)? {
	var node = Node('attribute', null, null, offset(), text());

	node.add('key', key);

	if (value !== null) {
		node.addList('spaces.0', value[0]);
		node.add('equal', value[1]);
		node.addList('spaces.1', value[2]);

		if (value[3] !== null) {
			node.add('value', value[3]);
		} else {
			node.flag('error');
			node.set('error', 'Attribute missing value');
		}
	}
	return node;
}

attributeAssignmentOperator = "=" {
	return Node('binary-operator', null, null, offset(), text());
}

// TODO handle white spaces without merging them with attributes
attributeList = head:attribute rest:(__ attribute)* {
	return lib.listFromSequence(head, rest);
}

attrValue =
	string
	/ unquotedAttr

unquotedAttr = $(idhead idrest*) {
	var node = Node('value', null, null, offset(), text());
	return node;
}

// --------------------------------------------------------------------- Strings

string =
	doubleQuoteString
	/ simpleQuoteString

doubleQuoteString = opening:doubleQuoteStringQuote raw:doubleQuoteStringContent? closing:doubleQuoteStringQuote? {
	var node = Node('string', null, null, offset(), text());

	node.add('opening', opening);

	if (raw !== null) {
		node.add('raw', raw);
	}

	if (closing !== null) {
		node.add('closing', closing);
	} else {
		node.flag('error');
		node.set('error', 'String not closed (missing double quote)');
	}

	return node;
}

doubleQuoteStringQuote = '"' {
	return Node('quotes.double', null, null, offset(), text());
}

doubleQuoteStringContent = $(!'"' .)+ {
	return Node('doubleQuoteString.content', null, null, offset(), text());
}


simpleQuoteString = opening:simpleQuoteStringQuote raw:simpleQuoteStringContent? closing:simpleQuoteStringQuote? {
	var node = Node('string', null, null, offset(), text());

	node.add('opening', opening);

	if (raw !== null) {
		node.add('raw', raw);
	}

	if (closing !== null) {
		node.add('closing', closing);
	} else {
		node.flag('error');
		node.set('error', 'String not closed (missing simple quote)');
	}

	return node;
}

simpleQuoteStringQuote = "'" {
	return Node('quotes.simple', null, null, offset(), text());
}

simpleQuoteStringContent = $(!"'" .)+ {
	return Node('simpleQuoteString.content', null, null, offset(), text());
}


// -------------------------------------------------------------------- Comments

comment = opening:commentOpening content:commentContent? closing:commentClosing? {
	var node = Node('comment', null, null, offset(), text());

	node.add('opening', opening);
	if (content !== null) {
		node.add('content', content);
	}
	if (closing !== null) {
		node.add('closing', closing);
	} else {
		node.flag('error');
		node.set('error', 'Comment is not closed');
	}

	return node;
}

commentOpening = "<!--" {
	return Node('opening', null, null, offset(), text());
}

commentClosing = "-->" {
	return Node('closing', null, null, offset(), text());
}

commentContent = (!commentClosing .)+ {
	return Node('content', null, null, offset(), text());
}

// --------------------------------------------------------------------- Various

__ = elements:(wsSequence / comment)* {
	return elements;
}

// Primitives ------------------------------------------------------------------

// -------------------------------------------------------------------------- ID

id = idhead idrest* {
	var node = Node('id', null, null, offset(), text());
	return node;
}
idhead = idchars
idrest = "-" / digit / idchars
idchars = alpha / idspecial
idspecial = [$_]

// ---------------------------------------------------------------- White spaces

ws = [ \r\n\t]

wsSequence =
	spaces
	/ tabs
	/ eols

spaces = content:" "+ {
	var node = Node('spaces', null, null, offset(), text());
	node.set('size', content.length);
	return node;
}

tabs = content:"\t"+ {
	var node = Node('tabs', null, null, offset(), text());
	node.set('size', content.length);
	return node;
}

eols = content:eol+ {
	var node = Node('eols', null, null, offset(), text());
	node.addList('eol', content);
	return node;
}

eol = value:("\r\n" / "\n" / "\r") {
	var node = Node('eol', null, null, offset(), text());
	node.set('value', value);
	return node;
}

// --------------------------------------------------------------------- Various

alpha = [a-zA-Z]
digit = [0-9]

// ------------------------------------------------------------------ Characters

closingAngleBracket = ">" {
	return Node('brackets.angle.closing', null, null, offset(), text());
}

slash = "/" {
	return Node('slash', null, null, offset(), text());
}
