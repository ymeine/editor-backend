var oop = require('oop').oop;



var NodeType = require('editor/node/type').NodeType;
var Location = require('editor/node/location').Location;





var definition = require('editor/node/node/common').definition;

definition.schema = {
	properties: [
		{names: ['type', 'class', 'category', 'cat'], ctor: NodeType, mixed: true},
		{names: ['location', 'loc', 'range', 'portion', 'piece'], ctor: Location, mixed: true},
		{names: ['source', 'src', 'input', 'text', 'content']}
	]
};

definition.init = function() {
	// Computes line and column indexes for end position
	if (this.source != null) {
		var end = this.location.end;

		if (end == null) {
			end = this.location.end = {};
		}

		if (end.index == null) {
			end.index = this.location.start.index + this.source.length;
		}

		// Too expensive? ---------------------------------------------------

		if (end.line == null || end.column == null) {
			var lines = prelude.lines(this.source);
			if (lines.length === 0) {
				lines = [""];
			}

			if (end.line == null && this.location.start.line != null) {
				this.location.end.line = this.location.start.line + lines.length - 1;
			}

			if (end.column == null) {
				if (lines.length == 1) {
					this.location.end.column = end.index + 1;
				} else {
					this.location.end.column = lines[lines.length - 1].length + 1;
				}
			}
		}
	}

	this.properties = {};
	this.flags = {};
	this.children = [];
	this.childrenIndex = {};
	this._index = 0;
};

definition.properties = [
	{names: ['key', 'entry'], desc: {
		get: function() {
			return this._key;
		}
	}},

	{names: ['index', 'idx'], desc: {
		get: function() {
			return this._index;
		}
	}},

	{names: ['path'], desc: {
		get: function() {
			var path;
			if (this.parent) {
				path = this.parent.path;
			} else {
				path = []
			}

			path.push(this);

			return path;
		}
	}},

	{names: ['branches', 'paths'], desc: {
		get: function() {
			var branches = [];

			var leaves = this.leaves;
			for (var i = 0, length = leaves.length; i < length; i++) {
				branches.push(leaves[i].path);
			}

			return branches;
		}
	}},

	{names: ['flat', 'flatten', 'list', 'lst'], desc: {
		get: function() {
			return this.pick(function() {return true;});
		}
	}},

	{names: ['leaves', 'edges'], desc: {
		get: function() {
			return this.pick(function(node) {
				return (node.children == null || node.children.length === 0);
			});
		}
	}}
];



/***********************************************************************
 * Children management
 **********************************************************************/

definition.methods._pushChild = function(id, child) {
	if (child == null) {
		child = {}
	};

	child = Node.factory(child);

	this.children.push(child);

	// Private properties ------------------------------------------------------

	child._index = this.children.length - 1;
	child._key = id;

	// Properties --------------------------------------------------------------

	child.parent = this;


	// Return ------------------------------------------------------------------

	return child;
};

var Node = oop.Class(definition);





exports.Node = Node;
