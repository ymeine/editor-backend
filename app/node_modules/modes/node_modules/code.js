var prelude = require('prelude-ls');

var oop = require('oop').oop;

var Parser = require('./pegjs-parser/parser').Parser;

var fs = require('fs');



// TODO Split the input definition in more models: one for location. Btw 'Location' should be made standard.
// Here location properties could be mixed with other properties

// TODO The input definition of a graph is not the same: it takes no text, since it considers the source property is already up to date. So just take the input specification of the other methods, just without the text. That is: combine specifications.

/*******************************************************************************
 * Specifications: schemas, properties, ...
 ******************************************************************************/

var sourcePropertyNames = ['text', 'txt', 'source', 'src', 'content', 'string', 'str'];

var updateInputSpec = {
	inputToSpec: {
		'String': function(input) {
			return {
				text: input,
				replace: true
			}
		}
		// Makes no sense for now...
		//,
		// 'Number': 'start'
	},
	properties: [
		{
			names: sourcePropertyNames,
			desc: 'The new text to set.',
			default: '',
			type: oop.types.String
		},
		{
			names: ['start', 'beginning', 'offset', 'index'],
			desc: 'INCLUSIVE, 0-based. The start index relative to the current code from which the given text will be set.',
			default: function() {return this.source.length;}, // appended text by default
			type: oop.types.Number
		},
		{
			names: ['end', 'stop'],
			desc: 'EXCLUSIVE, 0-based. The end index relative to the current code until which the given text will be set.',
			// inferred: 'start'
			type: oop.types.Number
		},
		{
			names: ['replace', 'erase', 'swap'],
			desc: 'A flag to ignore offsets and replace the entire current text with the given one.',
			default: false,
			type: oop.types.Boolean
		},
	]
};




/*******************************************************************************
 * Class: Code
 ******************************************************************************/

var Code = oop.class({
	name: 'Code',

	desc: 'Model for a source code. Kind of equivalent (but more specific) to the Document model in Eclipse.',

	// schema: {
	// 	properties: [
	// 		{names: ['parser'], type: Parser, required: true},
	// 		{names: ['input']}
	// 	]
	// },

	constructor: function(parser, input, extension) {
		this.parser = parser;
		this.extension = extension;

		this._source = '';
		this._graph = undefined;
		this._servicesCache = {};

		if (input != null) {
			this.update(input);
		}
	},

	properties: [
		{
			names: sourcePropertyNames,
			desc: {
				get: function() {
					return this._source;
				},
				set: function(input) {
					this.updateSource(input);
				}
			}
		},
		{
			names: ['graph', 'tree', 'ast', 'nodes', 'node'],
			desc: {
				get: function() {
					return this._graph;
				}
			}
		}
	],

	methods: {
		/**
		 * WARNING: Be careful of being efficient in this method, it is critical as this is the one called the most often!
		 *
		 * @todo? be able to specify a length property (computing end or start)
		 * @todo? be able to specify a unique end property for insertion (like it does for now with unique start)
		 * @todo be able to specify a pos property, for insertion, less confusing that the unique start or end property
		 */
		update: {
			desc: 'Updates the models of the code given a diff description in the source code.',
			process: function(spec) {

				if (!prelude.isType('Array', spec)) {
					spec = [spec];
				}
				for (var i = 0; i < spec.length; i++) {
					this.updateSource(spec[i]);
				}
				// this.updateGraph.process.call(this, spec);

				try {
					this._graph = this.parser.parse(this.source, {extension : this.extension});
					return {
						state: 'uptodate'
					};
				} catch (exception) {
					var dir = 'app/failures';
					try {
						fs.readdirSync(dir);
					} catch (ex) {
						fs.mkdirSync(dir);
					}

					dir += '/' + (new Date()).getTime();
					fs.readdirSync(dir);

					fs.writeFileSync(dir + '/source', this.source, "utf-8");
					fs.writeFileSync(
						dir + '/exception',
						exception.stack,
						"utf-8"
					);
					return {
						state: 'pending',
						exception: exception
					}
				}
			}
		},

		updateSource: {
			desc: 'Updates the source.',
			chainable: true,
			input: updateInputSpec,

			process: function(spec) {
				if (spec.replace) {
					this._source = spec.text;
				} else {
					if (spec.end == null) {
						spec.end = spec.start;
					}

					this._source =
						this.source.substring(0, spec.start) +
						spec.text +
						this.source.substring(spec.end, this.source.length);
				}
			}
		},

		updateGraph: {
			desc: 'Updates the graph.',
			chainable: true,
			input: updateInputSpec,

			process: function(spec) {
				if (spec.replace) {
					this._graph = this.parser.parse(this.source, {extension : this.extension});
				} else {
					this._graph = this.parser.parse(this.source, {extension : this.extension});
				}
			}
		}
	},

	prototype: {

		/**
		 * Adds a key-value pair to the cache
		 * @param {String} key
		 * @param {Object} value
		 */
		setCache: function(key, value) {
			this._servicesCache[key] = value;
		},

		/**
		 * Get a value from the cache
		 * @param {String} key
		 */
		getCache: function(key) {
			return this._servicesCache[key];
		},

		/**
		 * Resets the cache
		 */
		resetCache: function() {
			this._servicesCache = {};
		}
	}
})



exports.Code = Code;
