var prelude = require('prelude-ls');
var lodash = require('lodash');

var oop = require('oop').oop;



var NodeType = oop.Class({
	name: 'Node Type',

	schema: {
		inputToSpec: {
			'String': 'language'
		},
		properties: [
			{names: ['language', 'lang']},
			{names: ['element', 'elmt']}
		]
	},
	statics: {

		/**
		 * Converts the node type into a string following the format
		 * <language>:<element>
		 * @param type {NodeType}
		 * @return String
		 */
		toJSON: function (type) {
			return type.language == null || type.element == null ? "" : type.language + ":" + type.element;
		}
	}
});


var Position = oop.Class({
	name: 'Position',

	schema: {
		inputToSpec: {
			'Number': 'index'
		},
		properties: [
			{names: ['index', 'offset', 'position', 'pos', 'character', 'char']},
			{names: ['line', 'ln', 'l', 'L']},
			{names: ['column', 'col', 'c', 'C']}
		]
	}
});

var Location = oop.Class({
	name: 'Location',

	schema: {
		inputToSpec: {
			'Number': 'start'
		},
		properties: [
			{names: ['start', 'beginning', 'from'], ctor: Position},
			{names: ['end', 'stop', 'to'], ctor: Position}
		]
	},
	statics: {

		/**
		 * Converts the location into a string following the format
		 * <start.line>x<start.column>-><end.line>x<end.column>/<start.index>-><end.index>
		 * @param location {Location}
		 * @return String
		 */
		toJSON: function (location) {
			var start = location.start, end = location.end;
			return start.line + "x" + start.column + "->" + end.line + "x" + end.column + "/" + start.index + "->" + end.index;
		}
	}
});




var Node = oop.Class({

	name: 'Node',

	/***************************************************************************
	 * Construction
	 **************************************************************************/

	/**
	 * @param[in] language {String|Null|Any} The language to which this node belongs to. It is likely to be a string, but you can use any value you want, except `void` because this parameter is required. You can even use `null` to indicate that the language is unknown, or non-relevant for now.
	 *
	 * @param[in] element {String|Null|Any} The type of the element for the language this node belongs to. It is likely to be a string, but you can use any value you want, except `void` because this parameter is required. You can even use `null` to indicate that the type is unknown, or non-relevant for now.
	 *
	 * @param[in] line {Number} The number of the line where the element starts.
	 *
	 * @param[in] column {Number} The number of the column where the element starts.
	 *
	 * @param[in] index {Number} The number of the character - 0-based index of the total input - where the element starts.
	 *
	 * @todo Maybe we should use the Range type instead of Location, but this might be too heavy for the purpose...
	 */
	schema: {
		properties: [
			{names: ['type', 'class', 'category', 'cat'], ctor: NodeType, mixed: true},
			{names: ['location', 'loc', 'range', 'portion', 'piece'], ctor: Location, mixed: true},
			{names: ['source', 'src', 'input', 'text', 'content']}
		]
	},

	init: function() {
		// Computes line and column indexes for end position
		if (this.source != null) {
			var end = this.location.end;

			if (end == null) {
				end = this.location.end = {};
			}

			if (end.index == null) {
				end.index = this.location.start.index + this.source.length;
			}

			if (end.line == null || end.column == null) {
				var lines = prelude.lines(this.source);

				if (end.line == null && this.location.start.line != null) {
					this.location.end.line = this.location.start.line + lines.length - 1;
				}

				if (end.column == null) {
					if (lines.length == 1) {
						this.location.end.column = end.index + 1;
					} else {
						this.location.end.column = lines[lines.length - 1].length + 1;
					}
				}
			}
		}

		this.properties = {};
		this.flags = {};
		this.children = [];
		this.childrenIndex = {};
		this._index = 0;

		var id = 0;
		this.id = id;

		this.shared = {
			root: this,
			id: id,
			stats: {
				nodes: 1,
				leaves: 1
			},
			index: {}
		};
		this.shared.index[id] = this;
	},

	properties: [
		{names: ['key', 'entry'], desc: {
			get: function() {
				return this._key;
			}
		}},

		{names: ['index', 'idx'], desc: {
			get: function() {
				return this._index;
			}
		}},

		{names: ['path'], desc: {
			/**
			 * Returns the path to the node, that is the list of nodes leading to it from the root.
			 *
			 * In this kind of tree there can be only one path to a node, since there is only one parent per node.
			 */
			get: function() {
				var path;
				if (this.parent) {
					path = this.parent.path;
				} else {
					path = []
				}

				path.push(this);

				return path;
			}
		}},

		{names: ['branches', 'paths'], desc: {
			/**
			 * Branches are all the paths from the root to every leaves.
			 */
			get: function() {
				var branches = [];

				var leaves = this.leaves;
				for (var i = 0, length = leaves.length; i < length; i++) {
					branches.push(leaves[i].path);
				}

				return branches;
			}
		}},

		{names: ['flat', 'flatten', 'list', 'lst'], desc: {
			get: function() {
				return this.pick(function() {return true;});
			}
		}},

		{names: ['leaves', 'edges'], desc: {
			get: function() {
				return this.pick(function(node) {
					return (node.children == null || node.children.length === 0);
				});
			}
		}}
	],

	statics: {

		/**
		 * Creates a new node by merging the nodes present in the array. The type of the new node will be the same as the first node in the list.
		 * All flags and properties will be ignored
		 * @param {Array} nodes Array of consecutive nodes to merge
		 * @return {Node}
		 */
		merge: function (nodes) {
			if (!nodes || nodes.length === 0) {
				return nodes;
			}
			var newNodeObject = {
				type: nodes[0].type,
				location: {
					start: nodes[0].location.start,
					end: nodes[nodes.length - 1].location.end
				}
			};
			var source = [];
			for (var i = 0, len = nodes.length; i < len; i++) {
				source.push(nodes[i].source);
			}
			newNodeObject.source = source.join('');

			return new Node(newNodeObject);
		}
	},
	methods: {

		/**
		 * Generic function to add something to the node: a flag, a child, a list of children, or a property.
		 *
		 * WARNING: Won't work along with factories, the input must be a node or a list of nodes if you want to add nodes, otherwise you will add a property.
		 */
		put: function(id, item) {
			if (item == null) {
				return this.flag(id);
			}

			if (item instanceof Node) {
				return this.add(id, item);
			}

			if (prelude.isType('Array', item) && item.length > 0 && item[0] instanceof Node) {
				return this.addList(id, item);
			}

			return this.set(id, item);
		},

		/**
		 * Returns a copy of the graph.
		 *
		 * This actually recursively recreates the graph, adding children copies and so on.
		 *
		 * Be careful, the properties object however is not deeply cloned! We don't know what is put inside, and don't wanna perform a generic clone algorithm for now...
		 */
		copy: function() {
			// Creates a new node with the same basic properties
			var newNode = Node(this);

			// Children --------------------------------------------------------

			for (var id in this.childrenIndex) {
				var child = this.childrenIndex[id];

				if (prelude.isType('Array', child)) {
					var newList = [];
					for (var i = 0, length = child.length; i < length; i++) {
						newList.push(child[i].copy());
					}
					newNode.addList(id, newList);
				} else {
					newNode.add(id, child.copy());
				}
			}

			// Properties ------------------------------------------------------

			for (var key in this.properties) {
				newNode.set(key, this.properties[key]);
			}

			// Flags -----------------------------------------------------------

			for (var key in this.flags) {
				if (this.flags[key]) {
					newNode.flag(key);
				}
			}

			// Return ----------------------------------------------------------

			return newNode;
		},

		/***********************************************************************
		 * Children management
		 **********************************************************************/

		/**
		 * Adds a child to the children list.
		 */
		_pushChild: function(id, child) {
			if (child == null) {
				child = {}
			};

			child = Node.factory(child);

			this.children.push(child);

			// Private properties ----------------------------------------------

			child._index = this.children.length - 1;
			child._key = id;

			// Properties ------------------------------------------------------

			child.parent = this;


			var shared = this.shared;

			// Stats -----------------------------------------------------------

			shared.stats.nodes += child.shared.stats.nodes;
			shared.stats.leaves += child.shared.stats.leaves;
			if (child._index == 0) {
				shared.stats.leaves--;
			}

			// ID & index ------------------------------------------------------

			child.traverse(function(node) {
				shared.id++;
				node.id = shared.id;

				shared.index[node.id] = node;
			});

			// Shared object propagation ---------------------------------------

			this.traverse(function(node) {
				node.shared = shared;
			});

			// Return ----------------------------------------------------------

			return child;
		},

		/**
		 * Adds a child node with the given id.
		 */
		add: function(id, child) {
			child = this._pushChild(id, child);
			this.childrenIndex[id] = child;

			return child;
		},

		/**
		 * Adds a list of children nodes with the given id.
		 *
		 * These children are concatenated to the internal list of childrren, and each of them receives an the id along with an index property, 0-based indexed from the given list.
		 *
		 * The list is directly added under the given id to the children index.
		 */
		addList: function(id, list) {
			var finalList = [];

			for (var index = 0, length = list.length; index < length; index++) {
				var child = this._pushChild(id, list[index]);
				finalList.push(child);
				child._listIndex = index;
			}
			this.childrenIndex[id] = finalList;

			return finalList;
		},

		/***********************************************************************
		 * Properties management
		 **********************************************************************/

		set: function(key, value) {
			this.properties[key] = value;

			return value;
		},

		get: function(key) {
			return this.properties[key];
		},

		/**
		 * Sets a boolean property aiming at categorizing the node.
		 */
		flag: function(name) {
			this.flags[name] = true;
			return name;
		},

		unflag: function(name) {
			if (this.flags[name] != null) {
				this.flags[name] = false;
			}
			return name;
		},

		is: function(name) {
			return this.flags[name] === true;
		},

		/**
		 * Adds an error in the "errors" property of a node
		 * @param {String} error Error message
		 */
		addError: function(error) {
			var errors = this.get('errors') || [];
			errors.push(error);
			this.set('errors', errors);
		},

		/***********************************************************************
		 * Traversing
		 **********************************************************************/

		/**
		 * This is a node/parent-first traversing (top-down).
		 *
		 * @todo Bring here the implementation from my own framework (ymeine).
		 * @todo introduce other traversing orders, like bottom-up = children-first = depth-first
		 */
		traverse: function(cb, context) {
			if (context == null) {
				context = this;
			}

			cb.call(context, this);

			var children = this.children;
			for (var i = 0, length = children.length; i < length; i++) {
				children[i].traverse(cb, context);
			}
		},

		traverse2: {
			input: {
				inputToSpec: {
					'Function': 'cb'
				},
				properties: [
					{names: ['cb', 'callback', 'handler', 'func', 'fn', 'visitor', 'visit'], type: oop.types.Function, required: true},
					{names: ['type', 'traversal', 'order'], type: oop.types.String}
				]
			},

			process: function(spec) {
				if (spec.type == "depth-first") {
					this.traverse(spec.cb);
				} else {
					throw {
						msg: 'Traversal type not implemented',
						type: spec.type
					}
				}
			}
		},

		/**
		 * Picks up node matching the given predicate by traversing the graph.
		 */
		pick: function(predicate) {
			var list = [];

			if (prelude.isType('String', predicate)) {
				var flag = predicate;
				predicate = function(node) {
					return node.is(flag);
				}
			}

			if (!prelude.isType('Function', predicate)) {
				throw {
					msg: 'Given predicate is not a function, nor a flag.',
					predicate: predicate
				}
			}

			this.traverse(function(node) {
				if (predicate(node)) {
					list.push(node);
				}
			});

			return list;
		},

		map: function(transform) {
			var list = [];

			this.traverse(function(node) {
				list.push(transform(node));
			});

			return list;
		},

		pluck: function(property) {
			return this.map(function (node) {
				return node.property;
			});
		},

		/**
		 * Converts the graph into an object with a certain format.
		 *
		 * # Type
		 *
		 * - key: `type`
		 * - format: the output of `NodeType.toJSON`
		 *
		 * # Location
		 *
		 * - remark: start location only for now
		 * - key: `location`
		 * - format: the output of `Location.toJSON`
		 *
		 * # Properties
		 *
		 * - key: `properties`
		 * - output: not touched
		 *
		 * # Flags
		 *
		 * - key: `flags`
		 * - output: not touched
		 *
		 * # Children
		 *
		 * - key: `children`
		 * - output: list of children simplified in a recursive way by using this method
		 */
		toObject: function() {

			var flags = [];
			for (var key in this.flags) {
				if (this.flags[key] === true) {
					flags.push(key);
				}
			}

			var output = {
				type: NodeType.toJSON(this.type),
				location: Location.toJSON(this.location),
				children: []
			};

			if (Object.keys(this.properties).length != 0) {
				output.properties = this.properties;
			}

			if (flags.length > 0) {
				output.flags = flags.sort();
			}

			var children = this.children;

			for (var i = 0, length = children.length; i < length; i++) {
				output.children.push(children[i].toObject());
			}

			return output;
		},


		/***********************************************************************
		 * Checkings (for development essentially)
		 *
		 * TODO Use the new Range class to simplify algorithm. Maybe we'll have to create a new class to handle nicely a set of ranges.
		 **********************************************************************/

		 /**
		  * Check the coverage status of the children of a graph.
		  *
		  * For a node to be covered entirely, its children must cover the whole range of location.
		  *
		  * Example of coverage:
		  * - node: [0, 10]
		  * - children: [[0, 1], [1, 5], [5, 10]]
		  *
		  * Example of no coverage:
		  * - node: [0, 10]
		  * - children: [[1, 3], [5, 9]]
		  */
		checkCoverage: function() {
			var children = this.children;
			var reports = [];

			// Edge case: no child ---------------------------------------------
			// If it doesn't have children, sure it's covered

			if (children.length === 0) {
				return reports;
			}

			// Edge case: first child ------------------------------------------

			var firstChild = children[0];

			reports = reports.concat(firstChild.checkCoverage());

			var parentStart = this.location.start.index;
			var firstChildStart = firstChild.location.start.index;

			if (firstChildStart > parentStart) {
				reports.push({
					type: 'Missing first node',
					range: [parentStart, firstChildStart],
					inside: this.getId(),
					before: firstChild.getId()
				});
			}

			// Children check --------------------------------------------------
			// Every child checks that it is not to far from its previous one, and not inside or overlapping it!

			var previous = firstChild;
			for (var i = 1, length = children.length; i < length; i++) {
				var current = children[i];

				reports = reports.concat(current.checkCoverage());

				var previousStart = previous.location.start.index;
				var previousEnd = previous.location.end.index;

				var currentStart = current.location.start.index;
				var currentEnd = current.location.end.index;

				if (currentStart > previousEnd) {
					reports.push({
						msg: 'Missing node between two children',
						range: [previousEnd, currentStart],
						inside: this.getId(),
						after: previous.getId(),
						before: current.getId()
					});
				} else if (currentStart < previousEnd) {
					reports.push({
						msg: 'overlapping',
						range: [currentStart, previousEnd],
						inside: this.getId(),
						previous: previous.getId(),
						current: current.getId()
					});
				}

				previous = current;
			}

			// Edge case: last child ------------------------------------------

			var lastChild = children[children.length - 1];
			var parentEnd = this.location.end.index;
			var lastChildEnd = lastChild.location.end.index;
			if (lastChildEnd < parentEnd) {
				reports.push({
					msg: 'Missing final node',
					range: [lastChildEnd, parentEnd],
					inside: this.getId(),
					after: lastChild.getId()
				});
			}

			// Result ----------------------------------------------------------

			return reports;
		},

		/***********************************************************************
		 * Logging/debug/introspection
		 **********************************************************************/

		/**
		 * Generates a unique id to be able to identify the node.
		 */
		getId: function() {
			var list = prelude.map(function(node) {
				var key = node.key;

				if (key == null) {
					key = '<root>';
				} else {
					var index = node._listIndex;

					if (index != null) {
						key += '(' + index + ')';
					}
				}

				return key;
			}, this.path);

			return list.join(' - ');
		},

		getPosition: function() {
			return lodash.pluck(this.path, '_index').join('.');
		},

		/**
		 * @todo Handle flags
		 * @todo Change the format to avoid objects (already serialize the list of properties for instance): take care of the simpleTree method which depends on this one!
		 *
		 * Simplifies the graph structure (each object's structure).
		 *
		 * # Id
		 *
		 * - key: `id`
		 * - optional: yes, but makes sense only for the root node
		 * - format: depending on the existence of each of the two properties, gives either:
		 * 	- <id>
		 * 	- <id>.<index>
		 * 	- <index>
		 *  - nothing
		 *
		 * # Type
		 *
		 * - key: `type`
		 * - format: <language>.<element>
		 *
		 * # Location
		 *
		 * - remark: start location only for now
		 * - key: `loc`
		 * - format: L<line> C<column> (<index>)
		 *
		 * # Properties
		 *
		 * - key: `props`
		 * - optional: yes
		 * - output: not touched
		 *
		 * # Children
		 *
		 * - key: `children`
		 * - optional: yes
		 * - output: list of simplified children
		 */
		simplify: function() {
			// id --------------------------------------------------------------

			var idParentPart = join(this._key, '.', this._listIndex);
			var id = join(this._index, ' - ', idParentPart);

			// type ------------------------------------------------------------

			var language = this.type.language;
			var element = this.type.element;

			var type = language == null || element == null ? null : language + "." + element;

			// location --------------------------------------------------------

			var start = this.location.start;
			var end = this.location.end;

			// loc = "L#line C#column (#start)"---
			var loc = start.line + "x" + start.column + "->" + end.line + "x" + end.column + "/" + start.index + "->" + end.index;

			// properties ------------------------------------------------------

			var props = this.properties;

			// flags ------------------------------------------------------

			var flags = [];
			for (var key in this.flags) {
				if (this.flags[key] === true) {
					flags.push(key);
				}
			}

			// children --------------------------------------------------------

			var children;
			if (this.children.length !== 0) {
				children = [];
				for (var i = 0, length = this.children.length; i < length; ++i) {
					children.push(this.children[i].simplify());
				}
			}

			// Output ----------------------------------------------------------

			var output = {};

			if (id != null) {
				output.id = id;
			}

			output.type = type;
			output.loc = loc;

			if (flags != null) {
				output.flags = flags;
			}

			if (props != null) {
				output.props = props;
			}

			if (children != null) {
				output.children = children;
			}

			return output;
		},

		/**
		 * Builds a simple tree.
		 *
		 * This internally uses the simplified representation, and this documentation uses this model.
		 *
		 * Each node has the following format:
		 * {
		 * 	"<id | 'root'>: <type> (<loc>) [<properties>]": list of children converted to simple trees
		 * }
		 *
		 * @recursive
		 * @return A node converted to a simple tree
		 *
		 * @see simplify
		 */
		simpleTree: function() {
			// Properties computation ------------------------------------------

			var simplified = this.simplify();
			var id = simplified.id != null ? simplified.id : 'root';
			var type = simplified.type;
			var loc = simplified.loc;
			var props = simplified.props != null ? simplified.props : {};
			var flags = simplified.flags.join(', ');


			var properties = [];
			for (var key in props) {
				properties.push(key + "=" + props[key]);
			}
			properties = properties.join(', ');


			// Object creation -------------------------------------------------

			key = id + ": " + type + " (" + loc + ") [" + properties + "] <" + flags + ">";

			var value = [];
			for (var i = 0, length = this.children.length; i < length; i++) {
				value.push(this.children[i].simpleTree());
			}

			var output = {};
			output[key] = value;
			return output;
		}
	}
});



function join(part1, sep, part2) {
	if (part1 == null && part2 == null) {
		return;
	}
	if (part1 && part2 == null) {
		return part1;
	}
	if (part2 && part1 == null) {
		return part2;
	}
	return [part1, part2].join(sep);
}



exports.Node = Node;
