var prelude = require('prelude-ls');
var lodash = require('lodash');

var oop = require('oop').oop;



var NodeType = require('./node-type').NodeType;
var Location = require('./location').Location;



definition = {

	name: 'Node',

	statics: {

		/**
		 * Creates a new node by merging the nodes present in the array. The type of the new node will be the same as the first node in the list.
		 * All flags and properties will be ignored
		 * @param {Array} nodes Array of consecutive nodes to merge
		 * @return {Node}
		 */
		merge: function (nodes) {
			if (nodes == null || nodes.length === 0) {
				throw Error('No input provided for merge method');
			}
			var newNodeSpec = {
				type: nodes[0].type,
				location: {
					start: nodes[0].location.start,
					end: nodes[nodes.length - 1].location.end
				}
			};
			var source = [];
			for (var i = 0, len = nodes.length; i < len; i++) {
				source.push(nodes[i].source);
			}
			newNodeSpec.source = source.join('');

			return new this(newNodeSpec);
		}
	},
	methods: {

		/**
		 * Generic function to add something to the node: a flag, a child, a list of children, or a property.
		 *
		 * WARNING: Won't work along with factories, the input must be a node or a list of nodes if you want to add nodes, otherwise you will add a property.
		 */
		put: function(id, item) {
			if (item == null) {
				return this.flag(id);
			}

			if (item instanceof this.constructor) {
				return this.add(id, item);
			}

			if (prelude.isType('Array', item) && item.length > 0 && item[0] instanceof this.constructor) {
				return this.addList(id, item);
			}

			return this.set(id, item);
		},

		/**
		 * Returns a copy of the graph.
		 *
		 * This actually recursively recreates the graph, adding children copies and so on.
		 *
		 * Be careful, the properties object however is not deeply cloned! We don't know what is put inside, and don't wanna perform a generic clone algorithm for now...
		 */
		copy: function() {
			// Creates a new node with the same basic properties
			var ctor = this.constructor; // needed to avoid some side-effects with a wrong value of this (we need to let the engine decide the value of this, so to make a call without property access)
			var newNode = ctor(this);

			// Children --------------------------------------------------------

			for (var id in this.childrenIndex) {
				var child = this.childrenIndex[id];

				if (prelude.isType('Array', child)) {
					var newList = [];
					for (var i = 0, length = child.length; i < length; i++) {
						newList.push(child[i].copy());
					}
					newNode.addList(id, newList);
				} else {
					newNode.add(id, child.copy());
				}
			}

			// Properties ------------------------------------------------------

			for (var key in this.properties) {
				newNode.set(key, this.properties[key]);
			}

			// Flags -----------------------------------------------------------

			for (var key in this.flags) {
				if (this.flags[key]) {
					newNode.flag(key);
				}
			}

			// Return ----------------------------------------------------------

			return newNode;
		},

		/***********************************************************************
		 * Children management
		 **********************************************************************/

		/**
		 * Adds a child node with the given id.
		 */
		add: function(id, child) {
			child = this._pushChild(id, child);
			this.childrenIndex[id] = child;

			return child;
		},

		/**
		 * Adds a list of children nodes with the given id.
		 *
		 * These children are concatenated to the internal list of childrren, and each of them receives an the id along with an index property, 0-based indexed from the given list.
		 *
		 * The list is directly added under the given id to the children index.
		 */
		addList: function(id, list) {
			var finalList = [];

			for (var index = 0, length = list.length; index < length; index++) {
				var child = this._pushChild(id, list[index]);
				finalList.push(child);
				child._listIndex = index;
			}
			this.childrenIndex[id] = finalList;

			return finalList;
		},

		/***********************************************************************
		 * Properties management
		 **********************************************************************/

		set: function(key, value) {
			this.properties[key] = value;

			return value;
		},

		get: function(key) {
			return this.properties[key];
		},

		/**
		 * Sets a boolean property aiming at categorizing the node.
		 */
		flag: function(name) {
			this.flags[name] = true;
			return name;
		},

		unflag: function(name) {
			if (this.flags[name] != null) {
				this.flags[name] = false;
			}
			return name;
		},

		is: function(name) {
			return this.flags[name] === true;
		},

		/**
		 * Adds an error in the "errors" property of a node
		 * @param {String} error Error message
		 */
		addError: function(error) {
			var errors = this.get('errors') || [];
			errors.push(error);
			this.set('errors', errors);
		},

		/**
		 * Adds a warning in the "warnings" property of a node
		 * @param {String} warning Warning message
		 */
		addWarning: function(warning) {
			var warnings = this.get('warnings') || [];
			warnings.push(warning);
			this.set('warnings', warnings);
		},

		/**
		 * Overrides the location as if a certain string was prepended to the source. The string is described by the position of its end.
		 * @param {Position} offset
		 */
		moveContextLocation: function(offset) {
			var location = this.location;
			location.start.index += offset.index;
			// if (location.start.line == 1) { // if the current start location is not on the first line, then the column position will not be impacted
			// 	location.start.column += offset.column - 1;
			// }
			// location.start.line += offset.line - 1;
			location.end.index += offset.index;
			// if (location.end.line == 1) { // if the current end location is not on the first line, then the column position will not be impacted
			// 	location.end.column += offset.column - 1;
			// }
			// location.end.line += offset.line - 1;
			var children = this.children;
			if (children) {
				for (var i = 0, len = children.length; i < len; i++) {
					children[i].moveContextLocation(offset);
				}
			}
		},

		/***********************************************************************
		 * Traversing
		 **********************************************************************/

		/**
		 * This is a node/parent-first traversing (top-down).
		 *
		 * @todo Bring here the implementation from my own framework (ymeine).
		 * @todo introduce other traversing orders, like bottom-up = children-first = depth-first
		 */
		traverse: function(cb, context) {
			if (context == null) {
				context = this;
			}

			cb.call(context, this);

			var children = this.children;
			for (var i = 0, length = children.length; i < length; i++) {
				children[i].traverse(cb, context);
			}
		},

		traverse2: {
			input: {
				inputToSpec: {
					'Function': 'cb'
				},
				properties: [
					{names: ['cb', 'callback', 'handler', 'func', 'fn', 'visitor', 'visit'], type: oop.types.Function, required: true},
					{names: ['type', 'traversal', 'order'], type: oop.types.String}
				]
			},

			process: function(spec) {
				if (spec.type == "depth-first") {
					this.traverse(spec.cb);
				} else {
					throw {
						msg: 'Traversal type not implemented',
						type: spec.type
					}
				}
			}
		},

		/**
		 * Picks up node matching the given predicate by traversing the graph.
		 */
		pick: function(predicate) {
			var list = [];

			if (prelude.isType('String', predicate)) {
				var flag = predicate;
				predicate = function(node) {
					return node.is(flag);
				}
			}

			if (!prelude.isType('Function', predicate)) {
				throw {
					msg: 'Given predicate is not a function, nor a flag.',
					predicate: predicate
				}
			}

			this.traverse(function(node) {
				if (predicate(node)) {
					list.push(node);
				}
			});

			return list;
		},

		map: function(transform) {
			var list = [];

			this.traverse(function(node) {
				list.push(transform(node));
			});

			return list;
		},

		pluck: function(property) {
			return this.map(function (node) {
				return node.property;
			});
		},

		/**
		 * Converts the graph into an object with a certain format.
		 *
		 * # Type
		 *
		 * - key: `type`
		 * - format: the output of `NodeType.toJSON`
		 *
		 * # Location
		 *
		 * - remark: start location only for now
		 * - key: `location`
		 * - format: the output of `Location.toJSON`
		 *
		 * # Properties
		 *
		 * - key: `properties`
		 * - output: not touched
		 *
		 * # Flags
		 *
		 * - key: `flags`
		 * - output: not touched
		 *
		 * # Children
		 *
		 * - key: `children`
		 * - output: list of children simplified in a recursive way by using this method
		 */
		toObject: function() {

			var flags = [];
			for (var key in this.flags) {
				if (this.flags[key] === true) {
					flags.push(key);
				}
			}

			var output = {
				type: NodeType.toJSON(this.type),
				location: Location.toJSON(this.location),
				children: []
			};

			if (Object.keys(this.properties).length != 0) {
				output.properties = this.properties;
			}

			if (flags.length > 0) {
				output.flags = flags.sort();
			}

			var children = this.children;

			for (var i = 0, length = children.length; i < length; i++) {
				output.children.push(children[i].toObject());
			}

			return output;
		},


		/***********************************************************************
		 * Checkings (for development essentially)
		 *
		 * TODO Use the new Range class to simplify algorithm. Maybe we'll have to create a new class to handle nicely a set of ranges.
		 **********************************************************************/

		 /**
		  * Check the coverage status of the children of a graph.
		  *
		  * For a node to be covered entirely, its children must cover the whole range of location.
		  *
		  * Example of coverage:
		  * - node: [0, 10]
		  * - children: [[0, 1], [1, 5], [5, 10]]
		  *
		  * Example of no coverage:
		  * - node: [0, 10]
		  * - children: [[1, 3], [5, 9]]
		  */
		checkCoverage: function() {
			var children = this.children;
			var reports = [];

			// Edge case: no child ---------------------------------------------
			// If it doesn't have children, sure it's covered

			if (children.length === 0) {
				return reports;
			}

			// Edge case: first child ------------------------------------------

			var firstChild = children[0];

			reports = reports.concat(firstChild.checkCoverage());

			var parentStart = this.location.start.index;
			var firstChildStart = firstChild.location.start.index;

			if (firstChildStart > parentStart) {
				reports.push({
					type: 'Missing first node',
					range: [parentStart, firstChildStart],
					inside: this.getId(),
					before: firstChild.getId()
				});
			}

			// Children check --------------------------------------------------
			// Every child checks that it is not to far from its previous one, and not inside or overlapping it!

			var previous = firstChild;
			for (var i = 1, length = children.length; i < length; i++) {
				var current = children[i];

				reports = reports.concat(current.checkCoverage());

				var previousStart = previous.location.start.index;
				var previousEnd = previous.location.end.index;

				var currentStart = current.location.start.index;
				var currentEnd = current.location.end.index;

				if (currentStart > previousEnd) {
					reports.push({
						msg: 'Missing node between two children',
						range: [previousEnd, currentStart],
						inside: this.getId(),
						after: previous.getId(),
						before: current.getId()
					});
				} else if (currentStart < previousEnd) {
					reports.push({
						msg: 'overlapping',
						range: [currentStart, previousEnd],
						inside: this.getId(),
						previous: previous.getId(),
						current: current.getId()
					});
				}

				previous = current;
			}

			// Edge case: last child ------------------------------------------

			var lastChild = children[children.length - 1];
			var parentEnd = this.location.end.index;
			var lastChildEnd = lastChild.location.end.index;
			if (lastChildEnd < parentEnd) {
				reports.push({
					msg: 'Missing final node',
					range: [lastChildEnd, parentEnd],
					inside: this.getId(),
					after: lastChild.getId()
				});
			}

			// Result ----------------------------------------------------------

			return reports;
		},

		/***********************************************************************
		 * Logging/debug/introspection
		 **********************************************************************/

		/**
		 * Generates a unique id to be able to identify the node.
		 */
		getId: function() {
			var list = prelude.map(function(node) {
				var key = node.key;

				if (key == null) {
					key = '<root>';
				} else {
					var index = node._listIndex;

					if (index != null) {
						key += '(' + index + ')';
					}
				}

				return key;
			}, this.getPath());

			return list.join(' - ');
		},

		getPosition: function() {
			return lodash.pluck(this.getPath(), '_index').join('.');
		},

		getPath: function() {
			var path;
			if (this.parent) {
				path = this.parent.getPath();
			} else {
				path = []
			}

			path.push(this);

			return path;
		},

		/**
		 * @todo Handle flags
		 * @todo Change the format to avoid objects (already serialize the list of properties for instance): take care of the simpleTree method which depends on this one!
		 *
		 * Simplifies the graph structure (each object's structure).
		 *
		 * # Id
		 *
		 * - key: `id`
		 * - optional: yes, but makes sense only for the root node
		 * - format: depending on the existence of each of the two properties, gives either:
		 * 	- <id>
		 * 	- <id>.<index>
		 * 	- <index>
		 *  - nothing
		 *
		 * # Type
		 *
		 * - key: `type`
		 * - format: <language>.<element>
		 *
		 * # Location
		 *
		 * - remark: start location only for now
		 * - key: `loc`
		 * - format: L<line> C<column> (<index>)
		 *
		 * # Properties
		 *
		 * - key: `props`
		 * - optional: yes
		 * - output: not touched
		 *
		 * # Children
		 *
		 * - key: `children`
		 * - optional: yes
		 * - output: list of simplified children
		 */
		simplify: function() {
			// id --------------------------------------------------------------

			var idParentPart = join(this._key, '.', this._listIndex);
			var id = join(this._index, ' - ', idParentPart);

			// type ------------------------------------------------------------

			var language = this.type.language;
			var element = this.type.element;

			var type = language == null || element == null ? null : language + "." + element;

			// location --------------------------------------------------------

			var start = this.location.start;
			var end = this.location.end;

			// loc = "L#line C#column (#start)"---
			var loc = start.line + "x" + start.column + "->" + end.line + "x" + end.column + "/" + start.index + "->" + end.index;

			// properties ------------------------------------------------------

			var props = this.properties;

			// flags ------------------------------------------------------

			var flags = [];
			for (var key in this.flags) {
				if (this.flags[key] === true) {
					flags.push(key);
				}
			}

			// children --------------------------------------------------------

			var children;
			if (this.children.length !== 0) {
				children = [];
				for (var i = 0, length = this.children.length; i < length; ++i) {
					children.push(this.children[i].simplify());
				}
			}

			// Output ----------------------------------------------------------

			var output = {};

			if (id != null) {
				output.id = id;
			}

			output.type = type;
			output.loc = loc;

			if (flags != null) {
				output.flags = flags;
			}

			if (props != null) {
				output.props = props;
			}

			if (children != null) {
				output.children = children;
			}

			return output;
		},

		/**
		 * Builds a simple tree.
		 *
		 * This internally uses the simplified representation, and this documentation uses this model.
		 *
		 * Each node has the following format:
		 * {
		 * 	"<id | 'root'>: <type> (<loc>) [<properties>]": list of children converted to simple trees
		 * }
		 *
		 * @recursive
		 * @return A node converted to a simple tree
		 *
		 * @see simplify
		 */
		simpleTree: function() {
			// Properties computation ------------------------------------------

			var simplified = this.simplify();
			var id = simplified.id != null ? simplified.id : 'root';
			var type = simplified.type;
			var loc = simplified.loc;
			var props = simplified.props != null ? simplified.props : {};
			var flags = simplified.flags.join(', ');


			var properties = [];
			for (var key in props) {
				properties.push(key + "=" + props[key]);
			}
			properties = properties.join(', ');


			// Object creation -------------------------------------------------

			key = id + ": " + type + " (" + loc + ") [" + properties + "] <" + flags + ">";

			var value = [];
			for (var i = 0, length = this.children.length; i < length; i++) {
				value.push(this.children[i].simpleTree());
			}

			var output = {};
			output[key] = value;
			return output;
		}
	}
};



function join(part1, sep, part2) {
	if (part1 == null && part2 == null) {
		return;
	}
	if (part1 && part2 == null) {
		return part1;
	}
	if (part2 && part1 == null) {
		return part2;
	}
	return [part1, part2].join(sep);
}





Object.defineProperty(exports, 'definition', {
	get: function() {
		return Object.create(definition);
	}
});
