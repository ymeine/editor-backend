var oop = require('oop').oop;



var NodeType = require('./node-type').NodeType;
var Location = require('./location').Location;





var definition = require('./node-common').definition;

definition.schema = {
	properties: [
		{names: ['type', 'class', 'category', 'cat'], ctor: NodeType, mixed: true},
		{names: ['location', 'loc', 'range', 'portion', 'piece'], ctor: Location, mixed: true},
		{names: ['source', 'src', 'input', 'text', 'content']}
	]
};

definition.init = function() {
	// Computes line and column indexes for end position
	if (this.source != null) {
		var end = this.location.end;

		if (end == null) {
			end = this.location.end = {};
		}

		if (end.index == null) {
			end.index = this.location.start.index + this.source.length;
		}

		// Too expensive? ---------------------------------------------------

		if (end.line == null || end.column == null) {
			var lines = prelude.lines(this.source);
			if (lines.length === 0) {
				lines = [""];
			}

			if (end.line == null && this.location.start.line != null) {
				this.location.end.line = this.location.start.line + lines.length - 1;
			}

			if (end.column == null) {
				if (lines.length == 1) {
					this.location.end.column = end.index + 1;
				} else {
					this.location.end.column = lines[lines.length - 1].length + 1;
				}
			}
		}
	}

	this.properties = {};
	this.flags = {};
	this.children = [];
	this.childrenIndex = {};
	this._index = 0;
};

definition.properties = [
	{names: ['key', 'entry'], desc: {
		get: function() {
			return this._key;
		}
	}},

	{names: ['index', 'idx'], desc: {
		get: function() {
			return this._index;
		}
	}},

	{names: ['path'], desc: {
		/**
		 * Returns the path to the node, that is the list of nodes leading to it from the root.
		 *
		 * In this kind of tree there can be only one path to a node, since there is only one parent per node.
		 */
		get: function() {
			var path;
			if (this.parent) {
				path = this.parent.path;
			} else {
				path = []
			}

			path.push(this);

			return path;
		}
	}},

	{names: ['branches', 'paths'], desc: {
		/**
		 * Branches are all the paths from the root to every leaves.
		 */
		get: function() {
			var branches = [];

			var leaves = this.leaves;
			for (var i = 0, length = leaves.length; i < length; i++) {
				branches.push(leaves[i].path);
			}

			return branches;
		}
	}},

	{names: ['flat', 'flatten', 'list', 'lst'], desc: {
		get: function() {
			return this.pick(function() {return true;});
		}
	}},

	{names: ['leaves', 'edges'], desc: {
		get: function() {
			return this.pick(function(node) {
				return (node.children == null || node.children.length === 0);
			});
		}
	}}
];

/***********************************************************************
 * Children management
 **********************************************************************/

/**
 * Adds a child to the children list.
 */
definition.methods._pushChild = function(id, child) {
	if (child == null) {
		child = {}
	};

	child = Node.factory(child);

	this.children.push(child);

	// Private properties ----------------------------------------------

	child._index = this.children.length - 1;
	child._key = id;

	// Properties ------------------------------------------------------

	child.parent = this;


	// Return ----------------------------------------------------------

	return child;
};

var Node = oop.Class(definition);





exports.Node = Node;
