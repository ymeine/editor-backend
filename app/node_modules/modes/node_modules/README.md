Common resources for modes.

# File system layout

* [`README.md`](./README.md): this current file

Services:

* [`pegjs-parser`](./pegjs-parser): common resources used by parsers generated with PEG.js
* [`highlight`](./highlight): module for highlighting
* [`outline`](./outline): module for outline

Models:

* [`mode.js`](./mode.js): interface to all the services a mode can provide
* [`code.js`](./code.js): provides various models/representations and operations related to a source code
* [`session.js`](./session.js): a module to handle generically sessions, that is a data store working with ids as input

# Versioning

To version: _everything_.

# Documentation

## Code

### Model

__Representation of a source code unit.__ Sometimes called _source file_, or _document_. In more specialized contexts this can also be called _module_.

> What do you call a source code unit?

First, a [source code](http://en.wikipedia.org/wiki/Source_code) is a piece of text written in a programming language.

A unit is just something that is taken as a whole. So in this case a whole means that there is a notion of position, with the beginning of the unit and its end.

More concretely, it's like a file containing text, which is a special kind of text.

> What are the different representations?

The first one is the basic one, what the user enters and reads: the text itself. We call it `source`.

The second is a specific representations for programming languages: a graph. See [below](#node) for more information.

### API

#### Update

You can update the model of a code by providing an object describing what changed in its source code.

See documentation of the method `update` in the [code](./code.js).

## Node

The implementation of a node/graph, which is the data model for a formal language.

### Model

__Warning:__

* position information is a common pitfall: 0-based index, 1-based index, exclusive, inclusive

```
{
	type:
		language // language
		element // node type for that languages
	location:
		start: // inclusive, start position of the node: equivalent to where would be the caret in a source code editor
			line // 1-based line index
			column // 1-based column index
			index // 0-based total index
		end: // exclusive, end position of the node: equivalent to the position right on the right of the character
			line // 1-based line index
			column // 1-based column index
			index // 0-based total index
	source // the source code corresponding to this node

	properties: {} // A simple object for properties which are not directly linked nodes
	children: [] // Alllows notion of order among children
	childrenIndex: {} // Adds id mapping to children
}
```

## Mode

___DISCLAIMER___: the rest of this section needs review and work

### Parsing

___Describe here the model of a parser and of the data generated by the parser (node/graph, commonly known as AST) - maybe put the latter in a dedicated section, see the WEB-IDE project and also personal ones___

This is the core service, as without it you can't get the core model on which __every other service__ is based.

A parser returns a comprehensive model of a program, or part of it. It should also be able to handle updates of the model from parts of the whole program.

### Highlighting

Please refer to the [`highlight`](./highlight) submodule.

### Formatting

Formatting aims at changing a source code to give it a wanted and generally uniformed layout.

#### Concept

The concept of formatting code is simple:

* input: a source code, should be a relevant piece of code
* output: a source code with the same semantics, but formatted. It is likely to have the same syntax, what changes being mainly the white spaces.

So the main part to update in the model is related to tokens, especially white spaces, and thus is about information of positions (and length).

#### Impact

Formatting transforms the code, therefore it impacts almost all other features relying on positions:

* highlight: highlighting is implemented with ranges of text styles
* outline: the outline should remain the same, since the semantic should remain the same. However, if the outline either displays positions information or is linked to the editor (when you select a node in outline you jump to the corresponding position in the editor), it relies on positions
* ...

#### Implementation

For now, the API only allows you to pass in a source code, and to receive the new source code.

It's up to the client (frontend) to compute lengths difference.

However, you can in the same request ask for other information to be sent, like highlighting and outlining (to avoid the overhead of making those requests by yourself after).

### Folding

Folding aims at giving teh possibility to hide or show back portions of the source code, generally based on semantics.

#### Concept

The concept is rather simple.

A fold happens on a set of consecutive lines. Thus the output model of folding is a set of line ranges, possibly overlapping by the way.

How to compute these ranges is another story.

A foldable portion of source code is linked to semantics. In general, block statements are foldable, and every elements inside a block must be impacted.

After obtaining the AST of the source code, all nodes must be traversed. Only nodes corresponding to blocks will be processed.

Such a node should contain location information in the form of `line`, `column` (this feature is provided by the parsers I use). Just take the range of lines it spans and return it.

#### Impact

This depends on frontends capabilities.

Folding doesn't change anything in the core model, it's just a visual feature. Therefore it might impact all features concerning display of the code, like for instance highlighting.

However, services like highlighting are based on the core model, and give position information related to this model, not what is visually displayed. The frontend should be able to adapt this information to the fact that portions of code are not _physically_ shown.

# Contribute

## Generalize directional links between nodes

__For now every operations made on a graph consider children. Be able to consider the parent, or even siblings.__

For instance, this would give the possibility to do `addParent` (`setParent` in our case due to the nature of the graph).

Also, be able to traverse from children to parents. Maybe this one is weird.

## Use a more generic parser class

__For now the only standard Parser is designed too closely to PEG.js based parsers.__

We can see it in the definition of the [`Code`](./code.js) class, which accepts as input a parser. The only `Parser` class that could be used for the scema definition was the one inside the [`pegjs-parser`](./pegjs-parser) module.

Either externalize this class, or add an intermediate layer.

## Use the graph

For now, all features are implemented considering only an entire source code.

In the future, for better consistency, simplicity, performances and logic, everything should be working with the graph model, built from the AST.

For instance, a node could be attached the `foldable` property, the `type` property being already present and used for highlighting.

However, the algorithms already implemented will be useful to handle whole changes: these changes modify portions of graphs, it's like an entire source code, but nested in another.

One big thing will be handling slight changes in the graph, and updating the model in a minimum time.

## Lazy evaluations for the graph

__Use standard properties definitions (like proxies).__

This way there can be lazy updates of the graph.

When the user of the node requests a property value, the node can check if there are things to re-compute (basically its subgraph changed), does it, caches the value, and anyway returns this value.

The little overhead of using the getter anytime is worth it I guess.

## Handle properly multiple blocks on one line for folding

Think about the case where there are multiple multi-lines blocks on the same line: they overlap while one is ending and the other one is starting.

This would have some weird behavior when trying to fold them.

## Line/column model

__For performances, editors usually use a specific model to represent text, smarter than the one of a whole string.__

The most obvious model of a text as viewed in an editor is the 2D one: lines and columns.

This model should be implemented in the `Code` class, which would then be able to understand positions expressed in this model.

Also, mode services should be able to use it properly for more efficiency.

## Pairs matching

__Be able to return information about what matches in the source code__

Classical pairs matching, like brackets, or tags.

For instance, this code:

```html
<html></html>
```

would give a model like this:

```javascript
{
	matches: [
		{
			first: {start: 0, end: 1},
			second: {start: 5, end: 6}
		},
		{
			first: {start: 0, end: 6},
			second: {start: 6, end: 13}
		},
		{
			first: {start: 6, end: 7},
			second: {start: 12, end: 13}
		}
	]
}
```

with following remarks:

* `start` and `end` position are __0-based__ (stays consistent)
* `start` is __inclusive__, while `end` is __exclusive__ (stays consistent)
* omitting the end would give a default value being `start + 1`, to enclose one character
* caution as to be made with colliding pairs: here for instance if you are on an angle brackets, you are both on the brackets pairs and tags pair. However, this is up to the client to handle it properly: it might highlight both, like a stack.
