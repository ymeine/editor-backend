var prelude = require('prelude-ls');
var escapeHTML = require('escape-html');

var oop = require('oop').oop;
var dop = require('oop').dop;
var stderror = require('std/error');

var STDError = stderror.STDError;
var NotImplemented = stderror.NotImplemented;

var Code = require('./code').Code;
var Parser = require('./pegjs-parser/parser').Parser;
var Stylesheet = require('./highlight/stylesheet').Stylesheet;
var OutlineNode = require('./outline/outline-node').OutlineNode;

var visitors = {
	"validate" : require('./validation/visitor').ValidationVisitor
};


var FoldOptions = oop.Class({
	name: 'Fold options',

	desc: 'Options for the folding service.',

	schema: {
		properties: [
			{
				names: ['length', 'size'],
				type: oop.types.Boolean, default: false,
				desc: 'This flag tells to specify a range as a couple of start offset and text length instead of start offset and end offset'
			},
			{
				names: ['text', 'txt', 'char', 'chars', 'character', 'characters'],
				type: oop.types.Boolean, default: false,
				desc: 'This flag tells to use character offsets instead of line offsets to specify ranges'
			},
			{
				names: ['0-based'],
				type: oop.types.Boolean, default: false,
				desc: 'This flag tells to use 0-based offsets instead of 1-based. This applies for both line and character offsets modes.'
			}
		]
	}
});



var Mode = oop.Class({
	name: 'Mode',

	schema: {
		properties: [
			{
				names: ['parser'],
				type: Parser,
				required: true
				// validate: function(parser) {
				// 	if typeof parser?parse isnt 'function' => throw {
				// 		msg: 'Invalid given parser'
				// 		parser
				// 	}
				// }
			},
			{names: ['stylesheet', 'style'], output: '_stylesheet', type: Stylesheet},
			{names: ['highlightDefaultStyleNodes'], type: oop.types.Array, default: []},
			{names: ['outlineRules', 'outline']}
		]
	},

	init: function() {
		if (!prelude.isType('Function', this.parser.parse)) {
			throw STDError({
				msg: 'Invalid given parser',
				parser: this.parser
			});
		}
	},



	prototype: {
		/***********************************************************************
		 * Init
		 **********************************************************************/

		/**
		 * Creates a code instance using this mode from the given source.
		 */
		create: function(source) {
			return new Code(this.parser, source);
		},


		/***********************************************************************
		 * Model
		 **********************************************************************/

		/**
		 * Updates the code models.
		 */
		update: function(code, input) {
			code.resetCache();
			return code.update(input);
		},



		/**
		 * Unique service that allows to call several of them with a unique node traversal
		 * @param {Code} code
		 * @param {Object} options keys represent the visitors to call, values are the extra parameters to pass to the methods of the visitors
		 * @return {Object} It contains the response of every visitor
		 */
		multiService: function(code, options) {
			var graph = code.graph, response = {};
			if (graph == null) {
				 this.callVisitors(options, "emptyOutput", null, function(visitorName, result) {
					response[visitorName] = result;
				 });
				 return response;
			}

			/**
			 * Add cached results to the response and delete the corresponding service from options in order not run it again
			 */
			for (var visitor in options) {
				if (options.hasOwnProperty(visitor) && code.getCache(visitor) != null) {
					response[visitor] = code.getCache(visitor);
					delete options[visitor];
				}
			}

			if (Object.keys(options).length > 0) {
				this.callVisitors(options, "start", graph);
				var that = this;
				graph.traverse(function(node) {
					that.callVisitors(options, "processNode", node);
				});
				this.callVisitors(options, "end", null, function(visitorName, result) {
					response[visitorName] = result;
					code.setCache(visitorName, result);
				});
			}
			return response;
		},

		/**
		 * @param {Object} visitorsToCall keys represent the visitors to call, values are the extra parameters to pass to the methods of the visitors
		 * @param {String} method name of the method to call. Visitors implement 4 methods: "start", "emptyOutput", "processNode", "end". "processNode" method receives the node that is currently being traversed as an argument
		 * @param {Object} args First argument of the call
		 * @param {Function} callback Function to be called at the end of the processing. It receives as first argument the visitor name, as second argument the value returned by the method
		 */
		callVisitors: function(visitorsToCall, method, args, callback) {
			var result;
			for (var visitor in visitorsToCall) {
				if (visitorsToCall.hasOwnProperty(visitor) && visitors[visitor] != null) {
					result = visitors[visitor][method](args, visitorsToCall[visitor]);
					if (callback) {
						callback(visitor, result);
					}
				}
			}
		},


		/***********************************************************************
		 * Parse
		 **********************************************************************/

		/**
		 * Returns an AST.
		 *
		 * Basically it removes circular links from the graph, and also "internal" properties, especially the object shared between all nodes, which doens't make sense since it's not part of the tree.
		 *
		 * WARNING This returns a copy of the graph, because we must not modify it directly!
		 *
		 * FIXME Should use a depth-first traversal function: that way the 'children' propety used for traversal could be altered too
		 */
		parse: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {};
			}

			graph = graph.copy();

			graph.traverse(function(node) {
				delete node.parent;
				delete node.shared;

				delete node.childrenIndex;

				if (Object.keys(node.flags).length === 0) {
					delete node.flags;
				}
				if (Object.keys(node.properties).length === 0) {
					delete node.properties;
				}
			});

			return graph;
		},



		/***********************************************************************
		 * Highlight
		 *
		 * FIXME Ask the user of the mode (by instanciation or extension) to provide a way to get the stylesheet (not the static stylesheet itself, so we can do _hot_ changes)
		 * XXX Be able to provide a default stylesheet, common for all modes? This would require to have the same token names...
		 **********************************************************************/

		/**
		 * Returns the stylesheet used by this mode.
		 */
		stylesheet: function(code, input) {
			return this._stylesheet;
		},

		css: function() {
			return this._stylesheet.css();
		},

		/**
		 * @todo handle line endings more nicely
		 */
		html: function(code, input) {
			var source = code.source;

			var ranges = this.highlight(code, input).ranges;

			// Hack to append at the end any source code that has been taken into account by highlighting
			// This can happen only when the source code and the corresponding graph are not in sync, because parsing failed. There is more text that what the "highlighting thinks".

			var rangesEnd = ranges[ranges.length - 1].end;
			if (rangesEnd < source.length) {
				ranges.push({style: '_unparsed', start: rangesEnd, end: source.length})
			}

			// -----

			var output = "";
			for (var i = 0, length = ranges.length; i < length; i++) {
				var range = ranges[i];

				var str = escapeHTML(source.substring(range.start, range.end));
				str = str.replace(/\r\n/g, '\n');
				str = str.replace(/\n/g, '<br/>');
				str = str.replace(/ /g, '&nbsp;');
				str = str.replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;');

				var style = '';
				if (range.style != '') {
					style = Stylesheet.CLASS_PREFIX + this._stylesheet.convertSelectorToClassName(range.style);
				}
				output += "<span class='" + Stylesheet.CLASS_PREFIX + Stylesheet.DEFAULT_CLASS + " " + style + "'>" + str + "</span>";
			}

			return {
				ranges: ranges,
				html: output
			};
		},

		/**
		 * @todo Add an option to return more information in some ranges, like the ones about line endings
		 */
		highlight: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {};
			}

			// Marks -----------------------------------------------------------

			var fakeParent = false;
			if (graph.parent == null) {
				fakeParent = true;
				graph.parent = {
					fullpath: graph.type.element
				};
			}

			var leaves = [];
			var stylesheet = this._stylesheet;
			// Compute marks based on the node fullpath, and, if none is applicable, get marks from parents and put them into their children, to have all leaves marked, even if their marks have style corresponding to some ancestor nodes' types.

			graph.traverse(function(node) {
				var fullpath = node.parent.fullpath + "." + node.type.element;
				node.fullpath = fullpath;
				var style = stylesheet.getStyleFromPath(fullpath);
				node.highlight = style != null ? {
					style: style
				} : node.parent.highlight;

				// detect whether it is a leaf
				if (node.children == null || node.children.length === 0) {
					leaves.push(node);
				}
			});


			if (fakeParent) {
				delete graph.parent;
 			}

			// Transforms ------------------------------------------------------

			var ranges = prelude.map(function(token) {
				return {
					start: token.location.start.index,
					end: token.location.end.index,
					style: token.highlight != null ? token.highlight.style : ''
				};
			}, leaves);

			// Collapses -------------------------------------------------------

			// Collapses consecutive ranges that have the same style

			var finalRanges = [];
			var lastStyle;
			while (ranges.length > 0) {
				var range = ranges.shift();
				if (range.style === lastStyle) {
					finalRanges[finalRanges.length - 1].end = range.end;
				} else {
					finalRanges.push(range);
					lastStyle = range.style;
				}
			}

			// Returns ---------------------------------------------------------

			return {
				ranges: finalRanges
				// lineFeedType: ''
			};
		},

		/***********************************************************************
		 * Validation
		 **********************************************************************/

		/**
		 * Traverses the graph to look for errors and warnings
		 * @param {Code} code
		 * @return {Object} it contains the list of errors and warnings
		 */
		validate: function(code) {
			return this.multiService(code, {
				"validate" : null
			}).validate;
		},



		/***********************************************************************
		 * Outline
		 **********************************************************************/

		/**
		 * @fixme Why in the "specs" do I require a list of elements to be returned, while this will always be a single node (the root)? Or maybe I would like to avoid the root!
		 */
		outline: function(code, input) {
			var type = dop.extractProperty(input, {names: ['type'], default: "full"});

			var graph = code.graph;

			if (graph == null) {
				return {}
			}

			var outline;
			if (type === "simpleTree") {
				outline = this._outlineSimpleTree(graph.simpleTree());
			} else if (type === "simple") {
				outline = this._outlineNode(graph);
			} else if (type === "full") {
				outline = this._outline(graph);
			}  else if (type === "toObject") {
				outline = {children : graph.toObject()};
			}

			return {
				tree: outline.children
			};
		},

		_outline: function(node) {
			// label -----------------------------------------------------------

			var label = node.key || '<root>';

			// children --------------------------------------------------------

			var children = [];

			// ---------------------------------------------- classic properties

			children.push('type: ' + node.type.element);

			children.push({
				label: 'location',
				children: [
					{
						label: 'start',
						children: [
							'index: ' + node.location.start.index,
							'line: ' + node.location.start.line,
							'column: ' + node.location.start.column
						]
					},
					{
						label: 'end',
						children: [
							'index: ' + node.location.end.index,
							'line: ' + node.location.end.line,
							'column: ' + node.location.end.column
						]
					}
				]
			});

			var indexes = [
				'index: ' + node.index,
				'id: ' + node.id
			];

			if (node._listIndex != null) {
				indexes.push('list index: ' + node._listIndex);
			}

			children.push({
				label: 'indexes',
				children: indexes
			});

			// ----------------------------------------------------------- flags

			var flags = [];
			for (var flag in node.flags) {
				if (node.flags[flag] === true) {
					flags.push(flag);
				}
			}

			children.push({
				label: 'flags',
				children: flags
			});

			// ------------------------------------------------------ properties

			var properties = [];
			for (var property in node.properties) {
				properties.push(property + ' = ' + node.properties[property]);
			};

			children.push({
				label: 'properties',
				children: properties
			});

			// --------------------------------------------------- node children

			var outlinedChildren = [];
			for (var i = 0, length = node.children.length; i < length; i++) {
				outlinedChildren.push(this._outline(node.children[i]));
			}

			children.push({
				label: 'children',
				children: outlinedChildren
			});

			// Result ----------------------------------------------------------

			return OutlineNode({
				label: label,
				children: children
			});
		},

		_outlineNode: function(node) {
			// label -----------------------------------------------------------

			var id = node.key || 'root';
			var type = node.type.element;

			var label = id + ": " + type;

			// children --------------------------------------------------------

			var children = node.children;

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this._outlineNode(children[i]));
			}

			// Result ----------------------------------------------------------

			return {
				label: label,
				children: outlinedChildren
			};
		},

		_outlineSimpleTree: function(node) {
			// label -----------------------------------------------------------

			var label = Object.keys(node)[0];

			// children --------------------------------------------------------

			var children = node[label];

			var outlinedChildren = [];
			for (var i = 0, length = children.length; i < length; i++) {
				outlinedChildren.push(this._outlineSimpleTree(children[i]));
			}

			// Result ----------------------------------------------------------

			return {
				label: label,
				children: outlinedChildren
			};
		},


		/***********************************************************************
		 * Folding
		 **********************************************************************/

		/**
		 * Returns a list of foldable lines ranges.
		 *
		 * A range is a start line and a end line. Only "real" ranges are returned, that is you can be sure that the starts line is different from the end line.
		 *
		 * Foldable ranges are determined by block nodes. Every block is marked as potentially foldable. Then, blocks which don't span multiple lines are unmarked.
		 *
		 * Also, to avoid folding handles collision, blocks that start on the same line are avoided: between two colliding blocks, we want to keep the most enclosing ones. For that, there is a simple rule, strongly based on hypothesis made from the nature of the graph:
		 * - two blocks are likely to start on the same line only if they are contained in the same subtree
		 * - the most enclosing one is the closest to the root
		 */
		fold: function(code, input) {
			var graph = code.graph;

			if (graph == null) {
				return {};
			}

			graph = graph.copy();

			var options = FoldOptions.factory(input);

			// Marks & filters -------------------------------------------------

			// Marks block nodes as potentially foldable
			graph.traverse(function(node) {
				if (node.is('block')) {
					if (node.location.start.line != node.location.end.line) {
						node.flag('foldable');
					}
				}
			});

			// Unmarks blocks that begin on the same line of other bigger blocks
			graph.traverse(function(node) {
				if (node.is('foldable') && node.index == 0) {
					var lineRef = node.location.start.line;
					node.traverse(function(descendant) {
						if (descendant !== node && descendant.location.start.line == lineRef) {
							descendant.unflag('foldable');
						}
					});
				}
			});

			// Extracts --------------------------------------------------------

			var blocks = graph.pick('foldable');

			// Transforms ------------------------------------------------------

			var text = options['text'] === true;
			var zeroBased = options['0-based'] === true;
			var length = options['length'] === true;

			var ranges = prelude.map(function(node) {
				var start;
				var end;

				// Text offsets or line indexes --------------------------------
				// 0-based or 1-based indexes/offsets --------------------------

				if (text) {
					start = node.location.start.index;
					end = node.location.end.index;
					// Text offsets are already 0-based, contrary to line and column indexes
				} else {
					start = node.location.start.line;
					end = node.location.end.line;

					if (zeroBased) {
						start -= 1;
						end -= 1;
					}
				}

				// {start, end} or {start, length} specifications --------------

				var result = {
					start: start
				}

				if (length) {
					result.length = end - start;
				} else {
					result.end = end
				}

				return result;
			}, blocks);

			// Returns ---------------------------------------------------------

			return {
				ranges: ranges
			}
		},

		/***********************************************************************
		 * Graph visualization: for client-side
		 **********************************************************************/

		/**
		 * Returns analysis data about the graph representing the code, plus data to use for visual display of it.
		 */
		graph: function(code, options) {
			var graph = code.graph;

			if (graph == null) {
				return {}
			}

			var library = dop.extractProperty(options, {
				names: ['library', 'lib', 'type', 'framework', 'engine', 'system'],
				type: oop.types.String,
				default: "cytoscape"
			});

			var graphDisplay = this._graphBuilder[library](graph);

			return {
				//leaves: graph.shared.stats.leaves,
				//nodes: graph.shared.stats.nodes,
				graph: graphDisplay
			}
		},

		_graphBuilder: {
			/**
			 * Returns a representation of the graph suitable for the JavaScript InfoVis Toolkit library.
			 *
			 * @unimplemented
			 */
			jit: function(graph) {
				throw "Unimplemented";
			},

			/**
			 * Returns a representation of the graph suitable for the Cytoscape.js library.
			 *
			 * The easiest way of using Cytoscape.js is to explicitely specify separately nodes and their connections, that is edges.
			 *
			 * @return An object containing a list of nodes and a list of edges: {nodes, edges}
			 */
			cytoscape: function(graph) {
				var nodes = [];
				var edges = [];

				graph.traverse(function(node) {
					var nodeId = node.getPosition();

					// Node data -----------------------------------------------
					// A new node to go into the list of nodes

					var nodeData = {id: nodeId};

					nodeData.source = node.source;
					nodeData.element = node.type.element;

					var children = node.children;
					if (children.length === 0) {
						nodeData.name = nodeData.source;
					} else {
						nodeData.name = nodeData.element;
					}
					nodes.push({data: nodeData});

					// Edges ---------------------------------------------------
					// Connection between this node and its children

					for (var i = children.length - 1; i >= 0; i--) {
						var child = children[i];
						var childId = child.getPosition();
						edges.push({data: {id: nodeId + '-' + childId, source: nodeId, target: childId}});
					}

				});

				return {
					nodes: nodes,
					edges: edges
				}
			}
		}
	}
});



exports.Mode = Mode;
