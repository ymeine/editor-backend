// Initializer -----------------------------------------------------------------

{
	var lib = require('pegjs-parser/initializer');

	var NodeClass = function(type, start, end) {
		this.type = type;
		this.start = start;
		this.end = end;
		this.children = [];
	}

	NodeClass.prototype.add = function(node) {
		this.children.push(node);
	}

	NodeClass.prototype.addList = function(nodes) {
		this.children.push.apply(this.children, nodes);
	}

	var Node = function(type, offset, text) {
		return new NodeClass(type, offset, offset + text.length)
	}
}



// Grammar ---------------------------------------------------------------------

// ------------------------------------------------------------------------ Root

start = ws0:__ nodes:(nodeList __)? {
	var node = Node('root', offset(), text());

	node.addList(ws0);
	if (nodes !== "") {
		node.addList(nodes[0]);
		node.addList(nodes[1]);
	}

	return node;
}

// ----------------------------------------------------------------------- Nodes

node =
	text
	/ element

// FIXME This rule is used to parse a list of nodes contained in a block element (most of the time)
// These nodes are a mix of text, elements, and comments also.
// However, concerning the comments, they are "eaten" by the "__" rule, whose content is skipped here.
// So concretely if a node contains only text except some content inside, these comments are ignored because of that.
// Review the design of this rule
nodeList = head:node rest:(__ node)* {
	return lib.listFromSequence(head, rest);
}

// ------------------------------------------------------------------------ Text
// The particularity of the text node, is that it is not delimited as other nodes - that is elements, it's just everything that is not an element. So to detect the end of a text, we need to check if an element starts.

text = (!elementStart .)+ {return Node('text', offset(), text());}
elementStart = "<"

// -------------------------------------------------------------------- Elements
// WARNING the precedence in alternatives is important!

element =
	cdata
	/ directive
	/ inline
	/ block

// ----------------------------------------------------------------------- CDATA

cdata = opening:cdataOpening content:cdataContent? closing:cdataClosing {
	var node = Node('cdata', offset(), text());

	node.add(opening);
	if (content !== "") {
		node.add(content);
	}
	node.add(closing);

	return node;
}
cdataOpening = "<![CDATA[" {return Node('opening', offset(), text());}
cdataClosing = "]]>" {return Node('closing', offset(), text());}
cdataContent = (!cdataClosing .)+ {return Node('content', offset(), text());}

// ------------------------------------------------------------------- Directive

directive = opening:directiveOpening ws0:__ id:id ws1:__ content:directiveContent? closing:directiveClosing {
	var node = Node('directive', line(), text())

	node.add(opening);
	node.addList(ws0);
	node.add(id);
	node.addList(ws1);
	if (content !== "") {
		node.add(content);
	}
	node.add(closing);

	return node;
}

directiveOpening = "<!" {return Node('opening', offset(), text());}
directiveClosing = ">" {return Node('closing', offset(), text());}
directiveContent = (!directiveClosing .)+ {return Node('text', offset(), text());}

// ---------------------------------------------------------------------- Inline

inline = opening:inlineOpening id:inlineIds ws0:__ attributes:(attributeList __)? closing:inlineClosing {
	var node = Node('inline', offset(), text());

	node.add(opening);
	node.add(id);
	node.addList(ws0);
	if (attributes !== "") {
		node.addList(attributes[0]);
		node.addList(attributes[1]);
	}
	node.add(closing);

	return node;
}

inlineOpening = "<" {return Node('opening', offset(), text());}

inlineClosing = slash:(slash __)? closing:closingAngleBracket {
	var node = Node('closing', offset(), text());

	if (slash !== "") {
		node.add(slash[0]);
		node.addList(slash[1]);
	}
	node.add(closing);

	return node;
}

inlineIds = (
	"br"
	/ "link"
	/ "meta"
	/ "input"
	/ "img"
) {return Node('id', offset(), text());}

// ----------------------------------------------------------------------- Block

block = open:opening ws0:__ nodes:(nodeList __)? close:closing {
	var node = Node('block', offset(), text());

	node.add(open);
	node.addList(ws0);
	if (nodes !== "") {
		node.addList(nodes[0]);
		node.addList(nodes[1]);
	}
	node.add(close);

	return node;
}

opening = opening:openingOpening id:id ws0:__ attributes:(attributeList __)? closing:openingClosing {
	var node = Node('opening', offset(), text());

	node.add(opening);
	node.add(id);
	node.addList(ws0);
	if (attributes !== "") {
		node.addList(attributes[0]);
		node.addList(attributes[1]);
	}
	node.add(closing);

	return node;
}
openingOpening = "<" {return Node('opening', offset(), text());}
openingClosing = ">" {return Node('closing', offset(), text());}

closing = opening:closingOpening ws0:__ id:id ws1:__ closing:closingClosing {
	var node = Node('closing', offset(), text());

	node.add(opening);
	node.addList(ws0);
	node.add(id);
	node.addList(ws1);
	node.add(closing);

	return node;
}
closingOpening = "</" {return Node('opening', offset(), text());}
closingClosing = ">" {return Node('closing', offset(), text());}


// ------------------------------------------------------------------- Attribute

attribute = key:id value:(__ attributeAssignmentOperator __ attrValue)? {
	var node = Node('attribute', offset(), text());

	node.add(key);
	if (value !== "") {
		node.addList(value[0]);
		node.add(value[1]);
		node.addList(value[2]);
		node.add(value[3]);
	}

	return node;
}

attributeAssignmentOperator = "=" {return Node('attribute-assignment-operator', offset(), text());}

// TODO handle white spaces without merging them with attributes
attributeList = head:attribute rest:(__ attribute)* {
	return lib.listFromSequence(head, rest);
}

attrValue =
	string
	/ unquotedAttr

unquotedAttr = $(idhead idrest*) {return Node('value', offset(), text());}

// --------------------------------------------------------------------- Strings

string =
	doubleQuoteString
	/ simpleQuoteString

doubleQuoteString = opening:doubleQuoteStringQuote raw:doubleQuoteStringContent? closing:doubleQuoteStringQuote {
	var node = Node('string', offset(), text());

	node.add(opening);
	if (raw !== "") {
		node.add(raw);
	}
	node.add(closing);

	return node;
}
doubleQuoteStringQuote = '"' {return Node('quotes.double', offset(), text());}
doubleQuoteStringContent = $(!'"' .)+ {return Node('doubleQuoteString.content', offset(), text());}


simpleQuoteString = opening:simpleQuoteStringQuote raw:simpleQuoteStringContent? closing:simpleQuoteStringQuote {
	var node = Node('string', offset(), text());

	node.add(opening);
	if (raw !== "") {
		node.add(raw);
	}
	node.add(closing);

	return node;
}
simpleQuoteStringQuote = "'" {return Node('quotes.simple', offset(), text());}
simpleQuoteStringContent = $(!"'" .)+ {return Node('simpleQuoteString.content', offset(), text());}


// -------------------------------------------------------------------- Comments

comment = opening:commentOpening content:commentContent? closing:commentClosing {
	var node = Node('comment', offset(), text());

	node.add(opening);
	if (content !== "") {
		node.add(content);
	}
	node.add(closing);

	return node;
}
commentOpening = "<!--" {return Node('opening', offset(), text());}
commentClosing = "-->" {return Node('closing', offset(), text());}
commentContent = (!commentClosing .)+ {return Node('content', offset(), text());}



// --------------------------------------------------------------------- Various

__ = elements:(wsSequence / comment)* {
	return elements;
}

// Primitives ------------------------------------------------------------------

// -------------------------------------------------------------------------- ID

id = idhead idrest* {return Node('id', offset(), text());}
idhead = idchars
idrest = "-" / digit / idchars
idchars = alpha / idspecial
idspecial = [$_]

// ---------------------------------------------------------------- White spaces

ws = [ \r\n\t]

wsSequence =
	spaces
	/ tabs
	/ eols

spaces = content:" "+ {return Node('spaces', offset(), text());}
tabs = content:"\t"+ {return Node('tabs', offset(), text());}
eols = content:eol+ {
	var node = Node('eols', offset(), text());
	node.addList(content);
	return node;
}
eol = value:("\r\n" / "\n" / "\r") {return Node('eol', offset(), text());}

// --------------------------------------------------------------------- Various

alpha = [a-zA-Z]
digit = [0-9]

// ------------------------------------------------------------------ Characters

closingAngleBracket = ">" {return Node('brackets.angle.closing', offset(), text());}
slash = "/" {return Node('slash', offset(), text());}
