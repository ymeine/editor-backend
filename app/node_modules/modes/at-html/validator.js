var atContext = require('ariatemplates').context;



/**
 * List of statements to keep track of
 * @type {Array}
 */
var stack = [];

/**
 * List of node-error associations to be added only when the list of statements is coherent
 * @type {Array}
 */
var errors = [];

/**
 * Whether statement tracking is active
 * @type {Boolean}
 */
var tracking = true;

/**
 * Nestedness of macros
 * @type {Number}
 */
var inMacro = 0;

/**
 * Registers an error to be added on the relative node when the validation is over
 * @param {Object} node
 * @param {String} msg Error message
 */
var registerError = function(node, msg) {
	errors.push({
		node: node,
		msg: msg
	});
}

atContext.Aria.load({
	classes: ["aria.templates.Statements"],
	oncomplete: function() {
		var statements = atContext.aria.templates.Statements.ALLSTATEMENTS;

		module.exports = {

			/**
			 * Returns true if the statement exists in AT grammar
			 *
			 * @param {String} stm Statement name
			 * @return {Boolean}
			 */
			isValid: function(stm) {
				if (stm == "CDATA") {
					return true;
				}
				if (this.getType(stm) == "widget") {
					return true;
				}
				return stm in statements;
			},

			/**
			 * Returns true/false if the statement can be used as a container or not. It returns null if it can be used in both ways.
			 * It also returns null if the statement does not exist, so this method should be always be used after making sure that the statement is valid.
			 *
			 * @param {String} stm Statement name
			 * @return {Boolean}
			 */
			isContainer: function(stm) {
				if (!this.isValid(stm)) {
					return null;
				}
				if (stm == "CDATA") {
					return true;
				}
				return statements[stm].container;
			},

			/**
			 * Returns true if the statement is a root statement
			 *
			 * @param {String} stm Statement name
			 * @param {String} extension It can be "tpl" or "tml"
			 *
			 * @return {Boolean}
			 */
			isRoot: function(stm, extension) {
				if (extension == "tml") {
					return stm == "Library";
				}
				return stm == "Template";
			},

			/**
			 * Returns "statement" or "widget" according to the name of id
			 *
			 * @param {String} stm Statement name
			 * @return {String}
			 */
			getType: function(stm) {
				if (!stm) {
					return "statement";
				}
				if (stm.charAt(0) == "@") {
					return "widget"
				}
				return "statement";

			},

			/**
			 * Returns true if the statement must be in a Macro, false if it cannot, undefined or null if it can be used both inside and outside of a macro
			 *
			 * @param {String} stm Statement name
			 * @return {Boolean}
			 */
			isInMacro: function(stm) {
				if (!this.isValid(stm)) {
					return null;
				}

				if (this.getType(stm) == "widget") {
					return true;
				}

				if (stm == "CDATA") {
					return true;
				}
				return statements[stm].inMacro || null;
			},

			/**
			 * Returns the RegExp that should be used to validate the statement parameter
			 *
			 * @param {String} stm Statement name
			 * @return {RegExp}
			 */
			getParamRegExp: function(stm) {
				if (!this.isValid(stm)) {
					return null;
				}
				if (stm == "CDATA") {
					return /^$/;
				}
				return statements[stm].paramRegexp;

			},


			/**
			 * Validates the openingand closing tags of a block AT statement, an inline AT statement, the opening tag of an HTML element or an inline HTML element
			 *
			 * @param {Node} node Node containing the opening tag of a block statement/element or an inline statement/element
			 * @param {String} language It can be "html" or "at"
			 * @param {String} type It can be "inline", "opening" or "closing"
			 * @param {String} extension It can be "tpl" or "tml"
			 */
			validateTag: function(node, language, type, extension) {
				if (language == "html") {
					this.validateHTML(node, type);
				} else {
					this.validateAT(node, type, extension);
				}
			},


			validateHTML: function(node, type) {
				var id = node.childrenIndex.id ? node.childrenIndex.id.source : null;
				if (id == null) {
					node.addError("Missing tag name.");
				} else {
					if (tracking && inMacro == 0) {
						registerError(node, "No HTML is allowed outside of a macro statement.");
					}
				}
			},


			/**
			 * Validates the opening tag of a block AT statement or an inline AT statement by adding error if
			 * - the statement is not valid
			 * - the statement is used as a container and it should not (or viceversa)
			 * - the statement is being used as a root statement whereas it should not
			 * - the parameters do not respect the format demanded by the statement
			 * - the statement is outside of a macro, whereas it should not
			 *
			 * @param {Node} node Node containing the opening tag of a block statement or an inline statement
			 * @param {String} type It can be "inline", "opening" or "closing"
			 * @param {String} extension It can be "tpl" or "tml"
			 */
			validateAT: function(node, type, extension) {

				var isContainer = (type == "inline") ? false : true;
				var id = node.childrenIndex.id ? node.childrenIndex.id.source : null;

				if (id == null) {
					node.addError("Missing statement name.");
					this.stopTracking();
				} else {
					if (type != "closing") {
						this.validateATTracking(node, id, extension);
					}

					if (type == "opening") {
						this.notifyOpeningStatement(id);
					}

					if (type == "closing") {
						this.notifyClosingStatement(id);
					}


					if (this.getType(id) == "statement") {
						if (!this.isValid(id)) {
							node.addError("Statement " + id + " is not a valid statement.");
						} else {

							// block/inline validation
							if (this.isContainer(id) != null && this.isContainer(id) !== isContainer) {
								if (isContainer) {
									node.addError("Statement " + id + " should not be used as a container({" + id + " .../}).");
								} else {
									node.addError("Statement " + id + " should be used as a container({" + id + " ...}...{/" + id + "}).");
								}
							}


							// Parameter validation
							if (type != "closing") {

								var children = node.children, param = "", contentChild = node;
								for (var i = 0, len = children.length; i < len; i++) {
									if (children[i].type.element == "param") {
										contentChild = children[i];
										param = children[i].source;
										break;
									}
								}
								var paramRegExp = this.getParamRegExp(id);
								if (paramRegExp) {
									var match = param.match(paramRegExp);
									if (match == null) {
										contentChild.addError("The parameter of statement " + id + " is not valid.");
									}
								}
							}
						}
					}
				}
			},

			/**
			 * Used to reset the tracking
			 */
			restartTracking: function() {
				tracking = true;
				stack = [];
				errors = [];
				inMacro = 0;
			},

			/**
			 * Used to stop the tracking
			 */
			stopTracking: function() {
				tracking = false;
				stack = [];
				errors = [];
				inMacro = 0;
			},

			/**
			 * Whenever an opening statement is encountered, it is added in the stack to determine the statements tree
			 * @param {String} stm statement name
			 */
			notifyOpeningStatement: function(stm) {
				if (tracking) {
					stack.push(stm);
					if (stm == "macro") {
						inMacro++;
					}
				}
			},

			/**
			 * Whenever a closing statement is encountered, it is removed from the stack to determine the statements tree
			 * @param {String} stm statement name
			 */
			notifyClosingStatement: function(stm) {
				if (tracking) {
					var last = stack.pop();
					if (last && last == stm) {
						if (stm == "macro") {
							inMacro--;
						}
						this.reportErrors();
					} else {
						this.stopTracking();
					}
				}
			},

			/**
			 * Adds the errors that are registered in the errors array if the stack is clean and the tracking is active
			 */
			reportErrors: function() {
				if (tracking && stack.length == 0) {
					for (var i = 0, len = errors.length; i < len; i++) {
						errors[i].node.addError(errors[i].msg);
					}
					errors = [];
				}
			},

			/**
			 * Check that the statement
			 * - is inside a macro when it should be, and outside when it should not
			 * - is a root template when it should be
			 *
			 * @param {Object} node Node to decorate with errors if needed
			 * @param {String} stm Name of the statement
			 * @param {String} extension It can be "tpl" or "tml"
			 */
			validateATTracking: function(node, stm, extension) {

				if (tracking) {
					// root validation
					var isRoot = this.isRoot(stm, extension);
					if (isRoot && stack.length > 0) {
						registerError(node, "Statement " + stm + " can only be used as root.");
					}
					if (!isRoot && stack.length == 0) {
						registerError(node, "Statement " + stm + " cannot be used as root.");
					}

					// inMacro validation
					var isInMacro = this.isInMacro(stm);
					if (isInMacro != null) {
						if (isInMacro && inMacro == 0){
							registerError(node, "Statement " + stm + " can only be used inside a macro.");
						}
						if (!isInMacro && inMacro > 0){
							registerError(node, "Statement " + stm + " cannot be used inside a macro.");
						}
					}

				}
			},

			/**
			 * Check that an expression is inside a macro
			 *
			 * @param {Object} node Node to decorate with errors if needed
			 */
			validateATExpression: function(node) {
				if (tracking) {
					if (inMacro == 0){
						registerError(node, "Expressions can only be used inside a macro.");
					}
				}
			},

			/**
			 * Retrieves the last open statement
			 *
			 * @param {Number} index Non-positive number indicating how many steps to go up in the hierarchy
			 * @return {String} Statement
			 */
			getOpenStatement: function(index) {
				index = index || 0;
				if (stack.length < -index + 1) {
					return null;
				}
				return stack[stack.length + index - 1];
			},

			/**
			 * @return {Array} Stack of statements
			 */
			getStack: function() {
				return stack;
			}

		};
	}
});

atContext.execTimeouts();