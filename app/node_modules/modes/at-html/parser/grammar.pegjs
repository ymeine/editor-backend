// Initializer -----------------------------------------------------------------

{
	var lib = require('pegjs-parser/initializer');

	var Node = new lib.NodeInstancier('at-html');

	var validator = require('./validator.js');

	var blocks = [
		'block-statement',
		'block-widget',
		'multi-line-comment',
		'block-html-element',
		'html-comment'
	];

	Node.addHook(function(node) {
		if (blocks.indexOf(node.type.element) >= 0) {
			node.flag('block');
		}
	});

}



// Grammar ---------------------------------------------------------------------

start = content:ATHTMLnode* {
	var node =  Node('root', line(), column(), offset(), text());
	node.addList('content', lib.flatten(content));
	validator.reportErrors();
	validator.restartTracking();
	return node;
}

ATHTMLnode =
	  ATnode
	/ HTMLnode


// ------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------- AT -------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------

ATnode = values:(ATnodeInStatement / blockStatementClosingWithoutOpening / blockStatementClosingClosingWithoutOpening) {
	return lib.flatten([values]);
}

ATnodeInStatement = values:(wsSequence / comment / text / expression / statement) {
	return lib.flatten([values]);
}


// ------------------------------------------------------------------ Statements

statement =
	  cdata
	/ inlineStatement
	/ blockStatement
	/ blockStatementOpeningWithoutClosing
	/ statementOpeningWithoutClosing


// ---------------- Incomplete

blockStatementOpeningWithoutClosing = opening:blockStatementOpening {
	var id = opening.childrenIndex.id ? opening.childrenIndex.id.source : "";
	var type = validator.getType(id);

	var node = Node('block-' + type, line(), column(), offset(), text());
	opening.addError("Missing closing statement for " + type + " " + id);
	node.add('openTag', opening);
	return node;
}

blockStatementClosingWithoutOpening = closing:blockStatementClosing {
	var id = closing.childrenIndex.id ? closing.childrenIndex.id.source : "";
	var type = validator.getType(id);

	var node = Node('block-' + type, line(), column(), offset(), text());
	closing.addError("Missing opening statement for " + type + " " + id);
	node.add('closeTag', closing);
	return node;
}

blockStatementClosingClosingWithoutOpening = "{/" .* {
	var node = Node('statement', line(), column(), offset(), text());
	node.addError('This statement should be closed');
	return node;
}

statementOpeningWithoutClosing = "{" !"/" .* {
	var node = Node('statement', line(), column(), offset(), text());
	node.addError('This statement should be closed');
	return node;
}

blockStatementClosingWithoutOpeningInHtmlBlock = opening:blockStatementClosingOpening id:id? extra:extraParamsInBlockStatementClosing? closing:blockStatementClosingClosing&{
	var lastOpen = validator.getOpenStatement();
	id = id != "" ? id.source : null;
	if (id == null || lastOpen == null) {
		return true;
	}
	return lastOpen != id;
} {
	var idSource = id != "" ? id.source : null;
	var type = validator.getType(idSource);


	var node = Node('block-' + type, line(), column(), offset(), text());

	var innerNode = Node('closing', line(), column(), offset(), text());

	innerNode.addError("Missing opening statement for " + type + " " + idSource);

	innerNode.add('opening', opening);
	if (id != "") {
		innerNode.add('id', id);
	}
	validator.validateTag(innerNode, "at", "closing");

	if (extra != "") {
		innerNode.add('extra', extra)
	}
	innerNode.add('closing', closing);

	node.add('closeTag', innerNode);
	return node;
}


// ---------------- CDATA

cdata = opening:cdataOpening content:cdataContent? closing:cdataClosing {
	var node = Node('block-statement', line(), column(), offset(), text());

	node.add('opening', opening);

	if (content != "") {
		node.add('content', content);
	}

	node.add('closing', closing);

	return node;
}

cdataOpening = "{CDATA" [^}/]* "}" {
	var node = parse(text(), {
		startRule: 'blockStatementOpening'
	});
	var row = line(), col = column(), index = offset();
	node.moveContextLocation({
		line: row,
		column: col,
		index: index
	});
	return node;
}

cdataContent = (!cdataClosing .)+ {
	return Node('block-statement-content', line(), column(), offset(), text());
}

cdataClosing = "{/CDATA}" {
	var node = parse(text(), {
		startRule: 'blockStatementClosing'
	});
	var row = line(), col = column(), index = offset();
	node.moveContextLocation({
		line: row,
		column: col,
		index: index
	});
	return node;
}

// ---------------- Block

blockStatement = opening:blockStatementOpening content:blockStatementContent? closing:blockStatementClosing {
	var openingId = opening.childrenIndex.id ? opening.childrenIndex.id.source : "";
	var closingId = closing.childrenIndex.id ? closing.childrenIndex.id.source : "";
	var type = validator.getType(openingId);

	var node = Node('block-' + type, line(), column(), offset(), text());

	node.add('openTag', opening);
	if (content) {
		node.add('content', content);
	}
	node.add('closeTag', closing);

	if (openingId != closingId) {
		opening.addError("Opening statement " + openingId + " does not match the corresponding closing statement " + closingId + ".");
		closing.addError("Closing statement " + closingId + " does not match the corresponding opening statement " + openingId + ".");
	}

	return node;
}

blockStatementContent = content:(ATnodeInStatement / HTMLnode)* {
	if (content && content.length == 0) {
		return null;
	}
	var node =  Node('block-statement-content', line(), column(), offset(), text());
	if (content) {
		node.addList('content', lib.flatten(content));
	}
	return node;
}

blockStatementOpening = opening:blockStatementOpeningOpening !"/" id:id? param:blockStatementParam? closing:blockStatementOpeningClosing {
	var node = Node('opening', line(), column(), offset(), text());
	node.add('opening', opening);
	if (id) {
		node.add('id', id);
	}
	if (param) {
		node.addList('param', param);
	}

	validator.validateTag(node, "at", "opening");

	node.add('closing', closing);

	return node;
}

blockStatementOpeningOpening = "{" {
	return Node('opening', line(), column(), offset(), text());
}

blockStatementParam = genericParam


blockStatementOpeningClosing = "}" {
	return Node('closing', line(), column(), offset(), text());
}



blockStatementClosing = opening:blockStatementClosingOpening id:id? extra:extraParamsInBlockStatementClosing? closing:blockStatementClosingClosing {
	var node = Node('closing', line(), column(), offset(), text());
	node.add('opening', opening);
	if (id) {
		node.add('id', id);
	}
	validator.validateTag(node, "at", "closing");

	if (extra) {
		node.add('extra', extra)
	}
	node.add('closing', closing);

	return node;
}

extraParamsInBlockStatementClosing = $(!blockStatementClosingClosing .)+ {
	var node = Node('extra-parameters-in-closing-tag', line(), column(), offset(), text());
	node.addError('Closing statement tag does not accept any parameter. Remove everything between the statement name and the closing bracket');
	return node;
}

blockStatementClosingOpening = "{/" {
	return Node('opening', line(), column(), offset(), text());
}

blockStatementClosingClosing = "}" {
	return Node('closing', line(), column(), offset(), text());
}


// --------------- Inline

inlineStatement = opening:inlineOpening id:id? param:inlineStatementParam? closing:inlineClosing {
	var tagId = id ? id.source : "";
	var type = validator.getType(tagId);

	var node = Node('inline-' + type, line(), column(), offset(), text());

	node.add('opening', opening);

	if (id) {
		node.add('id', id);
	}
	if (param !== "") {
		node.addList('param', param);
	}

	validator.validateTag(node, "at", "inline");

	node.add('closing', closing);

	return node;
}

inlineOpening = "{" {
	return Node('opening', line(), column(), offset(), text());
}

inlineClosing = "/}" {
	return Node('closing', line(), column(), offset(), text());
}

inlineStatementParam = value:$(!"/}" .)*&{
	try {
		parse(value, {
			startRule: 'genericParam'
		});
		return true;
	} catch(ex) {
		return false;
	}
} {

	var nodes = parse(text(), {
		startRule: 'genericParam'
	});
	var row = line(), col = column(), index = offset();
	for (var i = 0, len = nodes.length; i < len; i++) {
		nodes[i].moveContextLocation({
			line: row,
			column: col,
			index: index
		});
	}
	return nodes;
}


// --------------------------------------------------------------- AT Expression

expression = opening:expressionOpening param:expressionParam? closing:expressionClosing? {
	var node = Node('expression', line(), column(), offset(), text());

	node.add('opening', opening);

	if (param !== "") {
		node.addList('param', param);
	}

	if (closing) {
		node.add('closing', closing);
	} else {
		node.addError("Expression should be closed.");
	}

	validator.validateATExpression(node);

	return node;
}

expressionOpening = "${" {
	return Node('opening', line(), column(), offset(), text());
}

expressionClosing = "}" {
	return Node('closing', line(), column(), offset(), text());
}

expressionParam = genericParam



// ----------------------------------------------------------------------- Param


genericParam =  value:(genericSingleParam)* {
	var nodes = lib.flatten(value), nodeCount = nodes.length, paramStart, paramEnd;
	for (paramStart = 0; paramStart < nodeCount && nodes[paramStart].type.element != 'param'; paramStart++) {}
	for (paramEnd = nodeCount - 1; paramEnd >= 0 && nodes[paramEnd].type.element != 'param'; paramEnd--) {}
	paramEnd++;
	if (paramEnd > paramStart) {
		var mergedNode = lib.NodeClass.merge(nodes.splice(paramStart, paramEnd - paramStart));
		mergedNode.set('value', mergedNode.source);
		nodes.splice(paramStart, 0, mergedNode);
	}
	return nodes;
}

genericSingleParam =
	  wsSequence
	/ braced
	/ nonbracedNospace

bracedParam = $(nonbraced / braced)

braced = value:$("{" content:bracedParam* "}") {
	var node = Node('param', line(), column(), offset(), text());
	node.set('value', value);
	return node;
}

nonbraced =  $(escapedBrackets / [^{}])+

nonbracedNospace = value:$(escapedBrackets / [^{} \r\n\t])+ {
	var node = Node('param', line(), column(), offset(), text());
	node.set('value', value);
	return node;
}

escapedBrackets = $("\\" ("{" / "}"))


// --------------------------------------------------- White spaces and Comments

__ = elements:(wsSequence / comment)* {
	return lib.flatten(elements);
}

// -------------------------------------------------------------------- Comments

comment =
	  multiLineComment
	/ singleLineComment

multiLineComment = opening:multiLineCommentOpening content:multiLineCommentContent? closing:multiLineCommentClosing? {
	var node = Node('multi-line-comment', line(), column(), offset(), text());

	node.add('opening', opening);
	if (content !== "") {
		node.add('content', content);
	}
	if (closing) {
		node.add('closing', closing);
	} else {
		node.addError("Multi line comment has not been closed.");
	}

	return node;
}

multiLineCommentOpening = "/*" {
	return Node('opening', line(), column(), offset(), text());
}

multiLineCommentClosing = "*/" {
	return Node('closing', line(), column(), offset(), text());
}

multiLineCommentContent = (!multiLineCommentClosing .)+ {
	return Node('content', line(), column(), offset(), text());
}

singleLineComment =  opening:singleLineCommentOpening content:singleLineCommentContent? {
	var node = Node('single-line-comment', line(), column(), offset(), text());

	node.add('opening', opening);
	if (content !== "") {
		node.add('content', content);
	}

	return node;
}

singleLineCommentOpening = "//" {
	return Node('opening', line(), column(), offset(), text());

}

singleLineCommentClosing = node:eol {
	return Node('closing', line(), column(), offset(), text());
}

singleLineCommentContent = (!singleLineCommentClosing .)+ {
	return Node('content', line(), column(), offset(), text());
}


// -------------------------------------------------------------------------- ID

id =
	  statementId
	/ widgetId

widgetId = "@" library:libraryId? separator:":"? widgetName:widgetName? {
	var node = Node('at-widget-id', line(), column(), offset(), text());

	if (library) {
		node.add('library', library);
	} else {
		node.addError('Missing widget library.')
	}

	if (widgetName) {
		node.add('widgetName', widgetName);
	} else {
		node.addError('Missing widget name.')
	}

	return node;
}

widgetName = simpleId {
	return Node('at-widget-name', line(), column(), offset(), text());
}

libraryId = simpleId {
	return Node('at-widget-library', line(), column(), offset(), text());
}

statementId = simpleId {
	return Node('at-id', line(), column(), offset(), text());
}

simpleId = idhead idrest*

idhead = idchars

idrest =
	  digit
	/ idchars

idchars =
	  alpha
	/ idspecial

idspecial = [_]





// ------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------- HTML -----------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------

HTMLnode = values:(htmlElement / blockHtmlElementClosingWithoutOpening / blockHtmlElementClosingClosingWithoutOpening) {
	return lib.flatten([values]);
}


HTMLnodeInBlock = values:(htmlElement) {
	return lib.flatten([values]);
}


// --------------------------------------------------------------- Elements



htmlElement =
	  htmlComment
	/ htmlCdata
	/ inlineHtmlElement
	/ blockHtmlElement
	/ blockHtmlElementOpeningWithoutClosing
	/ htmlElementOpeningWithoutClosing


// ---------------- Incomplete

blockHtmlElementOpeningWithoutClosing = opening:blockHtmlTagOpening {
	var id = opening.childrenIndex.id ? opening.childrenIndex.id.source : "";
	var node = Node('block-html-element', line(), column(), offset(), text());
	opening.addWarning("Closing tag for element " + id + " might be missing");
	node.add('openTag', opening);
	return node;
}

blockHtmlElementClosingWithoutOpening = closing:blockHtmlTagClosing {
	var id = closing.childrenIndex.id ? closing.childrenIndex.id.source : "";
	var node = Node('block-html-element', line(), column(), offset(), text());
	closing.addWarning("Opening tag for element " + id + " might be missing");
	node.add('closeTag', closing);
	return node;
}

blockHtmlElementClosingClosingWithoutOpening = "</" .* {
	var node = Node('html-element', line(), column(), offset(), text());
	node.addError('This tag should be closed');
	return node;
}

htmlElementOpeningWithoutClosing = "<" !"/" .* {
	var node = Node('html-element', line(), column(), offset(), text());
	node.addError('This tag should be closed');
	return node;
}

// ---------------- CDATA

htmlCdata = opening:htmlCdataOpening content:htmlCdataContent? closing:htmlCdataClosing {
	var node = Node('html-cdata', line(), column(), offset(), text());

	node.add('opening', opening);

	if (content !== "") {
		node.add('content', content);
	}

	node.add('closing', closing);

	return node;
}

htmlCdataOpening = "<![CDATA[" {
	return Node('opening', line(), column(), offset(), text());
}

htmlCdataClosing = "]]>" {
	return Node('closing', line(), column(), offset(), text());
}

htmlCdataContent = (!htmlCdataClosing .)+ {
	return Node('content', line(), column(), offset(), text());
}


// ---------------- Block


blockHtmlElement = opening:blockHtmlTagOpening content:blockHtmlTagContent? closing:blockHtmlTagClosing {
	var openingId = opening.childrenIndex.id ? opening.childrenIndex.id.source : "";
	var closingId = closing.childrenIndex.id ? closing.childrenIndex.id.source : "";

	var node = Node('block-html-element', line(), column(), offset(), text());

	node.add('openTag', opening);
	if (content) {
		node.add('content', content);
	}
	node.add('closeTag', closing);

	if (openingId != closingId) {
		opening.addError("Opening tag " + openingId + " does not match the corresponding closing tag " + closingId + ".");
		closing.addError("Closing tag " + closingId + " does not match the corresponding opening tag " + openingId + ".");
	}

	return node;
}

blockHtmlTagContent = content:(ATnodeInStatement / blockStatementClosingWithoutOpeningInHtmlBlock / HTMLnodeInBlock)* {
	if (content && content.length == 0) {
		return null;
	}
	var node =  Node('block-html-element-content', line(), column(), offset(), text());
	if (content) {
		node.addList('content', lib.flatten(content));
	}
	return node;
}

blockHtmlTagOpening = opening:blockHtmlTagOpeningOpening !"/" id:htmlId? param:blockHtmlTagParam? closing:blockHtmlTagOpeningClosing {
	var node = Node('opening', line(), column(), offset(), text());
	node.add('opening', opening);
	if (id) {
		node.add('id', id);
	}
	if (param) {
		node.addList('param', param);
	}

	validator.validateTag(node, "html", "opening");

	node.add('closing', closing);

	return node;
}

blockHtmlTagOpeningOpening = "<" {
	return Node('opening', line(), column(), offset(), text());
}

blockHtmlTagParam = values:(wsSequence / comment / textWithoutTagEnd / expression / statement)* {
	return lib.flatten(values);
}


blockHtmlTagOpeningClosing = ">" {
	return Node('closing', line(), column(), offset(), text());
}


blockHtmlTagClosing =opening:blockHtmlTagClosingOpening  ws0:wsSequence? id:htmlId? ws1:__? extra:extraParamsInBlockHtmlTagClosing? closing:blockHtmlTagClosingClosing {
	var node = Node('closing', line(), column(), offset(), text());
	node.add('opening', opening);

	if (ws0) {
		node.addList('spacesBeforeId', ws0);
	}

	if (id) {
		node.add('id', id);
	}
	validator.validateTag(node, "html", "closing");

	if (ws1) {
		node.addList('spacesAfterId', ws1);
	}

	if (extra) {
		node.add('extra', extra)
	}
	node.add('closing', closing);

	return node;
}

extraParamsInBlockHtmlTagClosing = $(!blockHtmlTagClosingClosing .)+ {
	var node = Node('extra-parameters-in-closing-tag', line(), column(), offset(), text());
	node.addError('Closing element tag does not accept any parameter.');
	return node;
}

blockHtmlTagClosingOpening = "</" {
	return Node('opening', line(), column(), offset(), text());
}

blockHtmlTagClosingClosing = ">" {
	return Node('closing', line(), column(), offset(), text());
}


// specific text for opening tag parameter
textWithoutTagEnd = $((escapedBrackets / !keywordStartAndTagEnd) .)+ {
	return Node('text', line(), column(), offset(), text());
}

keywordStartAndTagEnd = "${" / "{" / "/*" / "//" / "<" / "</" / ">"


// --------------- Inline

inlineHtmlElement = opening:inlineHtmlTagOpening id:htmlId? param:inlineHtmlTagParam? closing:inlineHtmlTagClosing {
	var tagId = id ? id.source : "";

	var node = Node('inline-html-element', line(), column(), offset(), text());

	node.add('opening', opening);
	if (id) {
		node.add('id', id);
	}
	if (param !== "") {
		node.addList('param', param);
	}

	node.add('closing', closing);
	validator.validateTag(node, "html", "inline");

	return node;
}

inlineHtmlTagOpening = "<" {
	return Node('opening', line(), column(), offset(), text());
}

inlineHtmlTagClosing = "/>" {
	return Node('closing', line(), column(), offset(), text());
}

inlineHtmlTagParam = value:$(!"/>" .)*&{
	try {
		parse(value, {
			startRule: 'htmlTagParamContent'
		});
		return true;
	} catch(ex) {
		return false;
	}
} {

	var nodes = parse(text(), {
		startRule: 'htmlTagParamContent'
	});
	var row = line(), col = column(), index = offset();
	for (var i = 0, len = nodes.length; i < len; i++) {
		nodes[i].moveContextLocation({
			line: row,
			column: col,
			index: index
		});
	}
	return nodes;
}

htmlTagParamContent = values:ATnodeInStatement* {
	return lib.flatten([values]);
}

// -------------------------------------------------------------------- Comments

htmlComment = opening:htmlCommentOpening content:htmlCommentContent? closing:htmlCommentClosing {
	var node = Node('html-comment', line(), column(), offset(), text());

	node.add('opening', opening);
	if (content !== "") {
		node.add('content', content);
	}
	node.add('closing', closing);

	return node;
}

htmlCommentOpening = "<!--" {
	return Node('opening', line(), column(), offset(), text());
}

htmlCommentClosing = "-->" {
	return Node('closing', line(), column(), offset(), text());
}

htmlCommentContent = (!htmlCommentClosing .)+ {
	return Node('content', line(), column(), offset(), text());
}


// -------------------------------------------------------------------------- ID


htmlId = htmlIdhead htmlIdrest* {
	return Node('html-id', line(), column(), offset(), text());
}

htmlIdhead = htmlIdchars

htmlIdrest =
	  digit
	/ htmlIdchars

htmlIdchars =
	  alpha
	/ htmlIdspecial

htmlIdspecial = [$_]


// ------------------------------------------------------------------------------------------------------------------------
// ------------------------------------------- COMMON ---------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------ Text


text = $((escapedBrackets / !keywordStart) .)+ {
	return Node('text', line(), column(), offset(), text());
}

keywordStart = "${" / "{" / "/*" / "//" / "<" / "</"


// ---------------------------------------------------------------- White spaces

ws = [ \r\n\t]

wsSequence = nodes:(spaces / tabs / eols)+

spaces = content:" "+ {
	var node = Node('spaces', line(), column(), offset(), text());
	node.set('size', content.length);
	return node;
}

tabs = content:"\t"+ {
	var node = Node('tabs', line(), column(), offset(), text());
	node.set('size', content.length);
	return node;
}

eols = content:eol+ {
	var node = Node('eols', line(), column(), offset(), text());
	node.set('size', content.length);
	return node;
}

eol = ("\r\n" / "\n" / "\r")

// --------------------------------------------------------------------- Strings

string =
	  doubleQuoteString
	/ singleQuoteString

doubleQuoteString = opening:doubleQuoteStringQuote raw:doubleQuoteStringContent? closing:doubleQuoteStringQuote {
	var node = Node('string', line(), column(), offset(), text());

	node.add('opening', opening);
	if (raw !== "") {
		node.add('raw', raw);
	}
	node.add('closing', closing);

	return node;
}

doubleQuoteStringQuote = '"' {
	return Node('quotes.double', line(), column(), offset(), text());
}

doubleQuoteStringContent = $(!'"' .)+ {
	return Node('doubleQuoteString.content', line(), column(), offset(), text());
}


singleQuoteString = opening:singleQuoteStringQuote raw:singleQuoteStringContent? closing:singleQuoteStringQuote {
	var node = Node('string', line(), column(), offset(), text());

	node.add('opening', opening);
	if (raw !== "") {
		node.add('raw', raw);
	}
	node.add('closing', closing);

	return node;
}

singleQuoteStringQuote = "'" {
	return Node('quotes.single', line(), column(), offset(), text());
}

singleQuoteStringContent = $(!"'" .)+ {
	return Node('singleQuoteString.content', line(), column(), offset(), text());
}


// --------------------------------------------------------------------- Various

word = $((!ws .)*)

alpha = [a-zA-Z]
digit = [0-9]

