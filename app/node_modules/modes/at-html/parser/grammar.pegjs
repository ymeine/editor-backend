// Initializer -----------------------------------------------------------------

{
	var lib = require('pegjs-parser/initializer');

	var Node = new lib.NodeInstancier('at-html');

	var statements = require('./statements.js');
}



// Grammar ---------------------------------------------------------------------


// ------------------------------------------------------------------ Statements

inlineStatement = opening:inlineOpening spaces:wsSequence? id:id param:inlineStatementParam? closing:inlineClosing {
	var node = Node('inline-statement', line(), column(), offset(), text());

	node.add('opening', opening);

	node.add('id', id);
	if (!statements.isValid(id.source)) {
		node.addError("Statement " + id.source + "is not a valid statement. Refer to http://www.ariatemplates.com/usermanual/latest/writing_templates for a statements description");
	} else if (statements.isContainer(id.source)) {
		node.addError("Statement " + id.source + "should be used as a container({" + id.source + " ...}...{/" + id.source + "}). Refer to http://www.ariatemplates.com/usermanual/latest/writing_templates for a statements description");
	}

	if (param !== "") {
		node.addList('param', param);
	}

	node.add('closing', closing);

	return node;
}

inlineOpening = "{" {
	return Node('opening', line(), column(), offset(), text());
}

inlineClosing = "/}" {
	return Node('closing', line(), column(), offset(), text());
}

inlineStatementParam =  value:(wsSequence / braced / nonbracedNospaceNoSlash)* {
	var nodes = lib.flatten(value), nodeCount = nodes.length, contentStart, contentEnd;
	for (contentStart = 0; contentStart < nodeCount && nodes[contentStart].type.element != 'content'; contentStart++) {}
	for (contentEnd = nodeCount - 1; contentEnd >= 0 && nodes[contentEnd].type.element != 'content'; contentEnd--) {}
	contentEnd++;
	if (contentEnd > contentStart) {
		var mergedNode = lib.NodeClass.merge(nodes.splice(contentStart, contentEnd - contentStart));
		mergedNode.set('value', mergedNode.source);
		nodes.splice(contentStart, 0, mergedNode);
	}
	return nodes;
}

nonbracedNospaceNoSlash = value:$(commentedBrackets / !"/}"&[^{} \r\n\t])+ {
	var node = Node('content', line(), column(), offset(), text());
	node.set('value', value);
	return node;
}
// --------------------------------------------------------------- AT Expression

expression = opening:expressionOpening content:expressionContent? closing:expressionClosing? {
	var node = Node('expression', line(), column(), offset(), text());

	node.add('opening', opening);

	if (content !== "") {
		node.addList('param', content);
	}

	if (closing) {
		node.add('closing', closing);
	} else {
		node.addError("Expression should be closed.");
	}

	return node;
}

expressionOpening = "${" {
	return Node('opening', line(), column(), offset(), text());
}

expressionClosing = "}" {
	return Node('closing', line(), column(), offset(), text());
}

// TODO: improve the definition of a content for an expression
expressionContent = genericContent



// ----------------------------------------------------------------------- Param
// FIXME There can be some }, depending on the context: JS Object, string, comment, ...

genericContent =  value:(genericSingleContent)* {
	var nodes = lib.flatten(value), nodeCount = nodes.length, contentStart, contentEnd;
	for (contentStart = 0; contentStart < nodeCount && nodes[contentStart].type.element != 'content'; contentStart++) {}
	for (contentEnd = nodeCount - 1; contentEnd >= 0 && nodes[contentEnd].type.element != 'content'; contentEnd--) {}
	contentEnd++;
	if (contentEnd > contentStart) {
		var mergedNode = lib.NodeClass.merge(nodes.splice(contentStart, contentEnd - contentStart));
		mergedNode.set('value', mergedNode.source);
		nodes.splice(contentStart, 0, mergedNode);
	}
	return nodes;
}

genericSingleContent =
	  wsSequence
	/ braced
	/ nonbracedNospace

bracedContent = $(nonbraced / braced)

braced = value:$("{" content:bracedContent* "}") {
	var node = Node('content', line(), column(), offset(), text());
	node.set('value', value);
	return node;
}

nonbraced =  $(commentedBrackets / [^{}])+

nonbracedNospace = value:$(commentedBrackets / [^{} \r\n\t])+ {
	var node = Node('content', line(), column(), offset(), text());
	node.set('value', value);
	return node;
}

commentedBrackets = $("\\" ("{" / "}"))


// --------------------------------------------------------------------- Strings

string =
	doubleQuoteString
	/ singleQuoteString

doubleQuoteString = opening:doubleQuoteStringQuote raw:doubleQuoteStringContent? closing:doubleQuoteStringQuote {
	var node = Node('string', line(), column(), offset(), text());

	node.add('opening', opening);
	if (raw !== "") {
		node.add('raw', raw);
	}
	node.add('closing', closing);

	return node;
}

doubleQuoteStringQuote = '"' {
	return Node('quotes.double', line(), column(), offset(), text());
}

doubleQuoteStringContent = $(!'"' .)+ {
	return Node('doubleQuoteString.content', line(), column(), offset(), text());
}


singleQuoteString = opening:singleQuoteStringQuote raw:singleQuoteStringContent? closing:singleQuoteStringQuote {
	var node = Node('string', line(), column(), offset(), text());

	node.add('opening', opening);
	if (raw !== "") {
		node.add('raw', raw);
	}
	node.add('closing', closing);

	return node;
}

singleQuoteStringQuote = "'" {
	return Node('quotes.single', line(), column(), offset(), text());
}

singleQuoteStringContent = $(!"'" .)+ {
	return Node('singleQuoteString.content', line(), column(), offset(), text());
}

// --------------------------------------------------- White spaces and Comments

__ = elements:(wsSequence / comment)* {
	return lib.flatten(elements);
}

// -------------------------------------------------------------------- Comments

comment =
	multiLineComment
	/ singleLineComment

multiLineComment = opening:multiLineCommentOpening content:multiLineCommentContent? closing:multiLineCommentClosing? {
	var node = Node('multi-line-comment', line(), column(), offset(), text());

	node.add('opening', opening);
	if (content !== "") {
		node.add('content', content);
	}
	if (closing) {
		node.add('closing', closing);
	} else {
		node.addError("Multi line comment has not been closed.");
	}

	return node;
}

multiLineCommentOpening = "/*" {
	return Node('opening', line(), column(), offset(), text());
}

multiLineCommentClosing = "*/" {
	return Node('closing', line(), column(), offset(), text());
}

multiLineCommentContent = (!multiLineCommentClosing .)+ {
	return Node('content', line(), column(), offset(), text());
}

singleLineComment =  opening:singleLineCommentOpening content:singleLineCommentContent? closing:singleLineCommentClosing {
	var node = Node('single-line-comment', line(), column(), offset(), text());

	node.add('opening', opening);
	if (content !== "") {
		node.add('content', content);
	}
	node.add('closing', closing);

	return node;
}

singleLineCommentOpening = "//" {
	return Node('opening', line(), column(), offset(), text());

}

singleLineCommentClosing = node:eol {
	return Node('closing', line(), column(), offset(), text());
}

singleLineCommentContent = (!singleLineCommentClosing .)+ {
	return Node('content', line(), column(), offset(), text());
}


// -------------------------------------------------------------------------- ID

id = idhead idrest* {
	return Node('at-id', line(), column(), offset(), text());
}
idhead = idchars
idrest = digit / idchars
idchars = alpha / idspecial
idspecial = [_]

// ---------------------------------------------------------------- White spaces

ws = [ \r\n\t]

wsSequence = (spaces / tabs / eols)+

spaces = content:" "+ {
	var node = Node('spaces', line(), column(), offset(), text());
	node.set('size', content.length);
	return node;
}

tabs = content:"\t"+ {
	var node = Node('tabs', line(), column(), offset(), text());
	node.set('size', content.length);
	return node;
}

eols = content:eol+ {
	var node = Node('eols', line(), column(), offset(), text());
	node.set('size', content.length);
	return node;
}

eol = ("\r\n" / "\n" / "\r")

// --------------------------------------------------------------------- Various

word = $((!ws .)*)

alpha = [a-zA-Z]
digit = [0-9]