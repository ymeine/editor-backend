_modes_ are modules implementing source code edition services for specific languages.

Modes might use each other.

# File system layout

* [`README.md`](./README.md): this current file
* [`parser.md`](./parser.md): an article about how to create a parser
* [`node_modules`](./node_modules): common resources for modes
* [`editor.js`](./editor.js): the exposed module to use for code edition services
* [`modeManager.js`](./modeManager.js): a module managing modes and documents

__All the other folders not already mentioned are modes, please refer to their respective documentations for more details.__

# Versioning

To version: _everything_.

# Documentation

## Editor

The editor module is the __unique__ entry point for code edition services.

For now, concretely it creates and exports an instance of a mode manager configured properly.

It adds to this manager all the modes already implemented.

## Mode manager

__The name is maybe not the best one. It should be more document (code documents) manager. Maybe split the two, creating a document manager using the mode manager__

The mode manager does two jobs:

* it manages documents, through what we call sessions
* it manages modes, they can be added and are then available for documents

### Modes

You can add modes to the mode manager, giving several names for those modes for more flexibility.

The modes are referenced through those names by documents, and are used to apply actual services on those documents.

### Documents

Documents can be initialized through this module: you need to specify which mode the document will use (among the available modes).

After initialization, a unique id is given for this document. This is mandatory to keep it, because this is what is used to refer to a document.

Then you can call mode services against a document by giving the id of this document and the name of the service, along with proper arguments. So you don't call directly a mode service providing a document, since documents are the center of the design. Instead, documents are linked to modes.

## Parser creation

This section describes the choices made to create parsers when this is needed.

### Requirements

Here are the requirements of the parser:

* generate at least a tree
* keep location information, both as ranges (indexes in the full string of code) and coordinates (line/column model)
* ...

### Choice

As all the points mentionned above involve a strong knowledge of both the language we want to manage and the theory of formal languages, we won't have time to totally proceed like this.

We will refer to a strong power which is the community.

One of the most famous tool to generate parsers in JavaScript is [PEG.js](http://pegjs.majda.cz/). It uses the [parsing expression grammar](http://en.wikipedia.org/wiki/Parsing_expression_grammar) model, which is apparently more powerful than other more traditional ones.

# Contribute

## Development

You can either work on the common library for modes in `node_modules` or on a specific mode.

Please refer to the respective documentations.

## Node ids for outline

__Add node ids to outline nodes and allow _contextual_ requests.__

For performances issues essentially, we should be able to work with partial parts of the outline model. Whether it is for update, or just data requests.

With a node id, the backend would be able to know with which node it is going to work. That way, the client would be able to request outline data for a given node.

For even more performances, a depth level of the requested subtree could be passed: this way the backend would send only a few nodes, with proper ids, and the client would request their own subtrees if needed, passing the ids.

## Documentation

* Put the article in `parser.md` about the parser creation process in the wiki
* Write an article more specifically about PEG.js
	* description, links to resources
	* how I use it in the project (how I prefer structuring the grammar, using the initializer, ...)
	* what interesting things I learned about PEG.js (which are not obvious): like the possibility to call a specific rule with the `parse` method
	* which version I use
