Parser for [Aria Templates](http://ariatemplates.com/).

# File system layout

* [`README.md`](./README.md): this current file
* [`.gitignore`](./.gitignore): Git related file

Parser:

* [`index.js`](./index.js): entry point of the parser
* `grammar.js`: generated from `grammar.pegjs`, it is the actual parser
* [`grammar.pegjs`](./grammar.pegjs): grammar of the parser
* [`options.json`](./options.json): options used for the generation of the parser

Test:

* [`test.js`](./test.js): file launching a standard test for PEG.js generated parsers, using the test data inside this module
* [`test.tpl`](./test.tpl): aimed at being a comprehensive input to test the parser

# Versioning

To ignore:

* `grammar.js`: file generated from the `grammar.pegjs` file

Optional: any convenient script to automate the commands described in the [`contribute`](#contribute) section below.

To version: _everything else_.

# Contribute

## Setup

To be able to use the parser, build the grammar with the following command executed from this folder:

```bash
..\..\..\..\..\node_modules\.bin\pegjs --extra-options-file options.json grammar.pegjs
```

This command uses a binary installed by npm, in the `node_modules` folder dedicated to third-parties libraries (in [the root folder](/) of the backend project). If it doesn't work, maybe the PEG.js module was not properly installed, try reinstalling it.

Optionally you can add the installed PEG.js binary to your system environment variable `PATH`, and then simply use the command: `pegjs --extra-options-file options.json grammar.pegjs`, which avoids the path mess.

Alternatively, you can also manually install PEG.js globally, with the good version, using the following command: `npm install -g git+https://github.com/dmajda/pegjs`.

## Try

To try it, you can launch the test set with the following command __after ensuring you built the grammar before__: `node test`.

## FIXME

### Completeness

Everything that is left not parsed in statement parameters can contain Aria Templates elements, which thus would not be handled. For instance:

* comments
* escaped characters like braces

These elements should be stripped off when applying another parser on it, however, their position and existence is important for edition purposes.

The ideal would be to do like with free text: free text can be broken with any AT statement, comment.

Statement parameters parsing should then follow the same pattern, like _eating everything until I encounter the beginning of something that can occur_ (here comments and escaped braces), or the end of the tag. However, mixing this with the hack made to handle brace pairs could be hard.

### Whitespaces in elements

> Is it always relevant to tell there can be some spaces between elements?

I mean, these spaces could be part of the element itself: think for instance of free text immediately following an opening tag, but think also that sometimes in some languages you consider this prepended spaces as an initial indent, for output formatting purposes. In this case, add the comment as an alternative element, and just consider whitespaces as free text.


## Backlog

1. Complete TODOs and FIXMEs from the code
1. Parse HTML parts and param statements
1. Really parse the content of the expression: `expr(|arg(:value)?)*`
	* Handle escaped pipes
1. Clean the grammar code
1. Use a graphical representation for the model: [Graphviz](http://www.graphviz.org/) or whatever

### Tokens and special characters

> Should everything be wrapped in nodes?

For instance, special characters determining the type of a node among other things, would they be part of the children of this node?

Having a single and comprehensive model for everything seems a good thing, and considering special characters as nodes (as we already do for whitespaces) would help simplifying the processings and so on.

## Notes

* When building the model of a source text with the parser, any element that represents a portion of the source code should be added as a child node, not a property. This makes it available for highlighting and so on.
	* be careful when some nodes are added and some properties are set: this is a case where you should check if properties shouldn't be nodes in fact. To help, have a look at the rule, if there is a mix of terminals and non-terminals (there shouldn't be).
	* be careful with semantics: a node with an angle bracket as content must have different purposes. __THERE SHOULDN'T BE NODES ONLY FOR CHARACTERS.__
* Adding a `value` property to a node is often useless, since this contains teh same text as the standard property of the nodes: `source`. However it can make sens for instance in a string literal: the source contains the quotes while the value contains the text only. More generally it works for delimited content.

# Documentation

## Model of a template

### Syntactic

* A template is a set of elements
* An element is either a statement or something else (this "something else" can be anything that doesn't look like a statement)
* A statement can be an inline statement or a block statement
* The single tag of the inline statement and the opening tag of a block statement have:
	* An id: the name of the statement
	* A possible parameter, which is "anything until the tag is closed"
* The closing tag of a block statement only has an id
* A block statement has a list of elements

In this model, there are two components left "fuzzy":

* The parameter of a statement: it's often pure JavaScript, like JSON objects for widgets, for loops parameters, pure expression for variable declaration, but sometimes it's a custom syntax, like for [foreach loops](http://ariatemplates.com/usermanual/latest/writing_templates#foreach)
* Everything else that is not a statement: depending on the kind of template, it will be either HTML, CSS or free text, that would need to be parsed _externally_ depending on the needs.

### Semantic

Here are some important general rules:

* a whole template is contained in a unique file
* every template has a unique root statement
* a template is a set of hierarchically structured statements between which there can be any text. It's a complete mixing of it, agnostic of what the text is. Think about XML, it's the same kind of things (however JSON is not for instance).
* template statements delegates to JavaScript statements as much as possible (to express loops, object literals, ...)

However we still want to treat the free text as a specific language, depending on the type of the template for instance (HTML, CSS, ...), but in a decoupled manner.

For this the principle is to combine the use of different parsers, to apply in specific order.
