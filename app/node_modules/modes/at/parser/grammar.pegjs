// Initializer -----------------------------------------------------------------

{
	var lib = require('pegjs-parser/initializer');

	var Node = new lib.NodeInstancier('at');

	var blocks = [
		'cdata',
		'text',
		'block'
	];

	Node.addHook(function(node) {
		if (blocks.indexOf(node.type.element) >= 0) {
			node.flag('block');
		}
	});
}



// Grammar ---------------------------------------------------------------------

// ------------------------------------------------------------------------ Root

start = ws0:__ nodes:(nodeList __)? {
	var node = Node('root', line(), column(), offset(), text());

	node.addList('spaces.0', ws0);

	if (nodes !== null) {
		node.addList('nodes', nodes[0]);
		node.addList('spaces.1', nodes[1]);
	}

	return node;
}

// ----------------------------------------------------------------------- Nodes

node =
	text
	/ statement

// FIXME This rule is used to parse a list of nodes contained in a block element (most of the time)
// These nodes are a mix of text, statements, and comments also.
// However, concerning the comments, they are "eaten" by the "__" rule, whose content is skipped here.
// So concretely if a node contains only text except some content inside, these comments are ignored because of that.
// Review the design of this rule
nodeList = head:node rest:(__ node)* {
	return lib.listFromSequence(head, rest);
}

// ------------------------------------------------------------------------ Text
// The particularity of the text node, is that it is not delimited as other nodes - that is elements, it's just everything that is not an element. So to detect the end of a text, we need to check if an element starts.

text = content:$(!statementStart .)+ {
	return Node('text', line(), column(), offset(), text());
}

statementStart = "${" / "{" / "/*" / "//"

// ------------------------------------------------------------------ Statements
// WARNING the precedence in alternatives is important!

statement =
	cdata
	/ expression
	/ inline
	/ block

// ----------------------------------------------------------------------- CDATA

cdata = opening:cdataOpening content:cdataContent? closing:cdataClosing {
	var node = Node('cdata', line(), column(), offset(), text());

	node.add('opening', opening);

	if (content != "") {
		node.add('content', content);
	}

	node.add('closing', closing);

	return node;
}

cdataOpening = opening:cdataOpeningOpening ws0:__ closing:cdataOpeningClosing {
	var node = Node('opening', line(), column(), offset(), text());
	node.add('opening', opening);
	node.addList('spaces.0', ws0);
	node.add('closing', closing);
	return node;
}

cdataOpeningOpening = "{CDATA" {
	return Node('opening', line(), column(), offset(), text());
}

cdataOpeningClosing = "}" {
	return Node('closing', line(), column(), offset(), text());
}

cdataClosing = "{/CDATA}" {
	return Node('closing', line(), column(), offset(), text());
}

cdataContent = (!cdataClosing .)+ {
	return Node('content', line(), column(), offset(), text());
}

// ------------------------------------------------------------------ Expression

expression = opening:expressionOpening ws0:__ content:expressionContent? ws1:__ closing:expressionClosing {
	var node = Node('expression', line(), column(), offset(), text());

	node.add('opening', opening);

	node.addList('spaces.0', ws0);

	if (content != "") {
		node.add('param', content);
	}

	node.addList('spaces.1', ws1);

	node.add('closing', closing);

	return node;
}

expressionOpening = "${" {
	return Node('opening', line(), column(), offset(), text());
}

expressionClosing = "}" {
	return Node('closing', line(), column(), offset(), text());
}

// expressionContent = blockStatementParam

// TODO The following is a work in progress and is not actually used for now

expressionContent = value:expressionValue? modifiers:expressionModifierList? {
	var node = Node('content', line(), column(), offset(), text());

	if (value != "") {
		node.add('value', value);
	}

	if (modifiers != "") {
		node.addList('modifiers', modifiers);
	}

	return node;
}

expressionValue = (!expressionModifierPrefix .)+ {
	return Node('text', line(), column(), offset(), text());
}

expressionModifierList = head:expressionModifier rest:(__ expressionModifier)* {
	return lib.listFromSequence(head, rest);
}

expressionModifier = prefix:expressionModifierPrefix name:expressionModifierName param:expressionModifierParam? {
	var node = Node('modifier', line(), column(), offset(), text());
	node.add('prefix', prefix);
	node.add('name', name);
	if (param != "") {
		node.add('param', param);
	}
	return node;
}

expressionModifierPrefix = "|" {
	return Node('prefix', line(), column(), offset(), text());
}

expressionModifierName = id

expressionModifierParam = prefix:expressionModifierParamPrefix value:expressionModifierParamValue? {
	var node = Node('modifier-param', line(), column(), offset(), text());
	node.add('prefix', prefix);
	if (value != "") {
		node.add('value', value);
	}
	return node;
}

expressionModifierParamPrefix = ":" {
	return Node('prefix', line(), column(), offset(), text());
}

// TODO Split param with commas?
expressionModifierParamValue = (!(expressionModifierPrefix / expressionClosing) .)+ {
	return Node('text', line(), column(), offset(), text());
}

// ---------------------------------------------------------------------- Inline

inline = opening:inlineOpening id:tagId param:inlineStatementParam? closing:inlineClosing {
	var node = Node('inline', line(), column(), offset(), text());

	node.add('opening', opening);
	node.add('id', id);

	if (param !== null) {
		node.add('param', param);
	}

	node.add('closing', closing);

	return node;
}

inlineOpening = "{" {
	return Node('opening', line(), column(), offset(), text());
}

inlineClosing = "/}" {
	return Node('closing', line(), column(), offset(), text());
}

inlineStatementParam = (!inlineClosing bracedContent)+ {
	return Node('text', line(), column(), offset(), text());
}

// ----------------------------------------------------------------------- Block

block = open:opening ws0:__ nodes:(nodeList __)? close:closing {
	var node = Node('block', line(), column(), offset(), text());
	node.add('openTag', open);
	node.addList('spaces.0', ws0);
	if (nodes !== null) {
		node.addList('nodes', nodes[0]);
		node.addList('spaces.1', nodes[1]);
	}
	node.add('closeTag', close);
	return node;
}

opening = opening:openingOpening id:tagId param:blockStatementParam? closing:openingClosing {
	var node = Node('opening', line(), column(), offset(), text());

	node.add('opening', opening);
	node.add('id', id);

	if (param !== null) {
		node.add('param', param);
	}

	node.add('closing', closing);

	return node;
}

openingOpening = "{" {
	return Node('opening', line(), column(), offset(), text());
}

openingClosing = "}" {
	return Node('closing', line(), column(), offset(), text());
}

blockStatementParam = (!"}" bracedContent)+ {
	return Node('text', line(), column(), offset(), text());
}

closing = opening:closingOpening id:tagId closing:closingClosing {
	var node = Node('closing', line(), column(), offset(), text());
	node.add('opening', opening);
	node.add('id', id);
	node.add('closing', closing);
	return node;
}

closingOpening = "{/" {
	return Node('opening', line(), column(), offset(), text());
}

closingClosing = "}" {
	return Node('closing', line(), column(), offset(), text());
}

// ------------------------------------------------------------------------- Tag
// FIXME Check the id specification

tagId =
	widgetId
	/ id

widgetId = prefix:widgetIdPrefix ns:id separator:widgetNamespaceWidgetSeparator widget:id {
	var node = Node('widgetId', line(), column(), offset(), text());
	node.add('prefix', prefix);
	node.add('namespace', ns);
	node.add('separator', separator)
	node.add('widget', widget);
	return node;
}

widgetIdPrefix = "@" {
	var node = Node('prefix', line(), column(), offset(), text());
}

widgetNamespaceWidgetSeparator = ":" {
	var node = Node('separator', line(), column(), offset(), text());
}

// ----------------------------------------------------------------------- Param
// FIXME There can be some }, depending on the context: JS Object, string, comment, ...

bracedContent = braced / nonbraced

braced = $("{" content:bracedContent* "}")

nonbraced =
	$("\\" ("{" / "}"))
	/ [^{}]

// -------------------------------------------------------------------- Comments

comment =
	multiLineComment
	/ singleLineComment

multiLineComment = opening:multiLineCommentOpening content:multiLineCommentContent? closing:multiLineCommentClosing {
	var node = Node('multi-line-comment', line(), column(), offset(), text());

	node.add('opening', opening);
	if (content !== null) {
		node.add('content', content);
	}
	node.add('closing', closing);

	return node;
}

multiLineCommentOpening = "/*" {
	return Node('opening', line(), column(), offset(), text());
}

multiLineCommentClosing = "*/" {
	return Node('closing', line(), column(), offset(), text());
}

multiLineCommentContent = (!multiLineCommentClosing .)+ {
	return Node('content', line(), column(), offset(), text());
}

singleLineComment =  opening:singleLineCommentOpening content:singleLineCommentContent? closing:singleLineCommentClosing {
	var node = Node('single-line-comment', line(), column(), offset(), text());

	node.add('opening', opening);
	if (content !== null) {
		node.add('content', content);
	}
	node.add('closing', closing);

	return node;
}

singleLineCommentOpening = "//" {
	return Node('opening', line(), column(), offset(), text());
}

singleLineCommentClosing = node:eol {
	node.type.element = 'closing' // dirty hack
	return node;
}

singleLineCommentContent = (!singleLineCommentClosing .)+ {
	return Node('content', line(), column(), offset(), text());
}

// --------------------------------------------------------------------- Various

__ = elements:(wsSequence / comment)* {
	return elements;
}

// Primitives ------------------------------------------------------------------

// -------------------------------------------------------------------------- ID

id = idhead idrest* {
	return Node('id', line(), column(), offset(), text());
}
idhead = idchars
idrest = digit / idchars
idchars = alpha / idspecial
idspecial = [_]

// ---------------------------------------------------------------- White spaces

ws = [ \r\n\t]

wsSequence =
	spaces
	/ tabs
	/ eols

spaces = content:" "+ {
	var node = Node('spaces', line(), column(), offset(), text());
	node.set('size', content.length);
	return node;
}

tabs = content:"\t"+ {
	var node = Node('tabs', line(), column(), offset(), text());
	node.set('size', content.length);
	return node;
}

eols = content:eol+ {
	var node = Node('eols', line(), column(), offset(), text());
	node.addList('eol', content);
	return node;
}

eol = value:("\r\n" / "\n" / "\r") {
	var node = Node('eol', line(), column(), offset(), text());
	node.set('value', value);
	return node;
}

// --------------------------------------------------------------------- Various

alpha = [a-zA-Z]
digit = [0-9]
